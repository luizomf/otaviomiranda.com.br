<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>
      f-strings em Python: coisas que voc√™ n√£o sabia - Ot√°vio Miranda
    </title>
    <meta
      name="description"
      content="Uso avan√ßado de f-strings para formata√ß√£o de strings em Python, cobrindo conceitos como concatena√ß√£o, formata√ß√£o num√©rica e representa√ß√£o em diferentes bases num√©ricas."
    />

    <link rel="stylesheet" href="../../css/markdown.css" />

    <link rel="icon" type="image/webp" href="../../imgs/favicon-1.webp" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown-light.min.css"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
    />

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>
  <body>
    <nav class="breadcrumb-nav">
      <a href="/">&larr; ir para in√≠cio</a>

      <form
        id="main-search"
        action="https://www.google.com/search"
        method="get"
        target="_blank"
      >
        <input type="search" name="q" placeholder="Buscar no site via Google" />
        <button type="submit">Buscar</button>
      </form>
    </nav>

    <article class="markdown-body" id="content"></article>

    <!-- prettier-ignore -->
    <script type="text/markdown" id="markdown-source">


# f-strings em Python: coisas que voc√™ n√£o sabia

Este texto detalha o uso avan√ßado de f-strings para formata√ß√£o de strings em
Python, cobrindo conceitos como concatena√ß√£o, formata√ß√£o num√©rica e
representa√ß√£o em diferentes bases num√©ricas e muito mais.

Eu usei como base a transcri√ß√£o do meu v√≠deo original dispon√≠vel em:

- <a href="https://youtu.be/yt2wPLGMAA0" target="_blank" rel="noopener noreferrer">üì∫
  f-strings em Python: coisas que voc√™ n√£o sabia ‚Üó</a>

O texto aqui n√£o √© exatamente id√™ntico ao do v√≠deo. Eu coloquei alguns c√≥digos
adicionais, exemplos diferentes e aprofundei um pouco mais em algumas coisas que
acho interessantes. Espero que goste.

**Dica:** descrevo MUITAS coisas interessantes nos coment√°rios dos c√≥digos de
exemplo, n√£o deixe de ler.

---

## Introdu√ß√£o: concatena√ß√£o de Strings e Inteiros

Um desafio comum em programa√ß√£o √© concatenar strings com outros tipos de dados,
como inteiros. Em Python, tentar concatenar diretamente uma string com um
inteiro resulta em um erro de tipo:

```python
numero = 123456789
texto = "N√∫mero: "

# Erro: TypeError: can only concatenate str (not "int") to str
print(texto + numero)
```

Para resolver isso, podemos converter o inteiro para string usando a fun√ß√£o
`str()`:

```python
numero = 123456789
texto = "N√∫mero: "

print(texto + str(numero))
# Sa√≠da: N√∫mero: 123456789
```

No entanto, as `f-strings` oferecem uma solu√ß√£o mais elegante, leg√≠vel e
eficiente para esse tipo de formata√ß√£o. Vamos ver o que podemos fazer com
`f-strings` no Python.

---

## Introdu√ß√£o √†s `f-strings`

As `f-strings` (formata√ß√£o de string com prefixo `f`) oferecem uma sintaxe
concisa e poderosa para incorporar express√µes Python diretamente dentro de uma
string (`str`). Para utiliz√°-las, basta prefixar a string com `f` e envolver a
express√£o desejada entre chaves `{}`.

Exemplo b√°sico:

```python
numero = 123456789
texto = f"N√∫mero: {numero}"
print(texto) # Sa√≠da: N√∫mero: 123456789
```

Esse m√©todo funciona com strings de uma ou v√°rias linhas, com aspas simples,
duplas ou triplas.

---

## Formata√ß√£o Num√©rica com f-strings

As `f-strings` permitem formatar n√∫meros de forma clara e flex√≠vel. √â poss√≠vel
aplicar separadores de milhares e controlar o n√∫mero de casas decimais com
extrema facilidade.

---

### Separadores de milhares

Podemos usar **underscores (`_`)** ou **v√≠rgulas (`,`)** ap√≥s os dois pontos
(`:`) dentro das chaves:

```python
numero = 123456789

print(f"N√∫mero com underscores: {numero:_}") # Sa√≠da: 123_456_789
print(f"N√∫mero com v√≠rgulas: {numero:,}") # Sa√≠da: 123,456,789
```

---

### Casas decimais com `.nf`

Para n√∫meros de ponto flutuante, usamos `.nf`, onde `n` representa o n√∫mero de
casas decimais desejado:

```python
numero_float = 198.7654321

print(f"Duas casas decimais: {numero_float:.2f}") # Sa√≠da: 198.77
print(f"Sem casas decimais: {numero_float:.0f}") # Sa√≠da: 199
print(f"Quatro casas decimais: {numero_float:.4f}") # Sa√≠da: 198.7654
```

---

### Combinando separador de milhar e casas decimais

Tamb√©m √© poss√≠vel aplicar as duas formata√ß√µes simultaneamente:

```python
numero_float = 19876.54321

print(f"Formatado: {numero_float:,.2f}") # Sa√≠da: 19,876.54
```

Essa abordagem torna a exibi√ß√£o de valores num√©ricos mais leg√≠vel. Ideal para
dashboards, relat√≥rios ou qualquer interface voltada ao usu√°rio.

---

### Sinais de Mais e Menos (positivo e negativo)

√â poss√≠vel exibir explicitamente os sinais de n√∫meros positivos e negativos.
Para isso, usamos `+` para for√ßar o sinal do n√∫mero:

```python
numero_positivo = 10
numero_negativo = -10

print(f"N√∫mero positivo: {numero_positivo:+d}") # Sa√≠da: +10
print(f"N√∫mero negativo: {numero_negativo:d}") # Sa√≠da: -10
```

> Obs: o `+` exibe o sinal tamb√©m para n√∫meros positivos. Para negativos, o
> sinal j√° aparece por padr√£o.

---

### Porcentagem

Para representar um n√∫mero como porcentagem, usamos o especificador `%`, junto
com a defini√ß√£o de casas decimais:

```python
porcentagem = 0.98

print(f"Porcentagem: {porcentagem:.2%}") # Sa√≠da: 98.00%
```

---

### Convers√£o entre: `bytes`, `int`, `str` e `hex`

√â poss√≠vel formatar dados e os converter em string, inteiro, float, hexadecimal,
octal, ascii, bin√°rio, e mais, usando fun√ß√µes built-in do pr√≥prio Python e
adicionar o poder das `f-strings` no meio do caminho para ampliar, e muito,
muito as possibilidades.

Tamb√©m podemos usar `!r` para exibir a representa√ß√£o do objeto na sa√≠da, ou
seja, chamar `repr()` diretamente de dentro de uma `f-string`.

**Lembre-se:** ao usar `f-strings`, estamos automaticamente convertendo um
objeto em `str`. As strings tem um m√©todo `encode` que vai converter o valor
bytes. O m√©todo `decode` converte bytes de volta em string. Eu falo bastante
sobre isso nesse artigo:

- [Normaliza√ß√£o Unicode em Python](https://www.otaviomiranda.com.br/2020/normalizacao-unicode-em-python/)

Vamos ver como fazer um inteiro virar hexadecimal, depois bytes, string e, por
fim, voltar a ser inteiro. Vamos fazer isso s√≥ para voc√™ ver a combina√ß√£o de
coisas de strings, built-ins do Python e `f-strings` (um grande poder nas suas
m√£os).

```python
# Um n√∫mero inteiro normal
num = 255 # 255
# O n√∫mero inteiro convertido em hexadecimal com f-string
int_to_hex = f'{num:x}' # 'ff'
# O hexadecimal convertido em bytes
hex_to_bytes = int_to_hex.encode('utf-8') # b'ff'
# Bytes convertido em str de volta
bytes_str = hex_to_bytes.decode('utf-8') # 'ff'
# Voltamos a string para int
hex_to_int = int(bytes_str, 16) # 255

print(f"{num = !r}") # num = 255
print(f"{int_to_hex = !r}") # int_to_hex = 'ff'
print(f"{hex_to_bytes = !r}") # hex_to_bytes = b'ff'
print(f"{bytes_str = !r}") # bytes_str = 'ff'
print(f"{hex_to_int = !r}") # hex_to_int = 255

# Mais :o, :b, :x e :X
print(f"Inteiro: {num = !r}") # Inteiro: num = 255
print(f"Octal: {num = :o}") # Octal: num = 377
print(f'Bin√°rio: {num = :b}') # Bin√°rio: num = 11111111
print(f"hexadecimal: {num = :x}") # hexadecimal: num = ff
print(f"HEXADECIMAL: {num = :X}") # HEXADECIMAL: num = FF
```

- `:o` exibe o valor em octal.
- `:b` exibe o valor em bin√°rio
- `:x` exibe o valor em hexadecimal (min√∫sculo).
- `:X` exibe o valor em hexadecimal em mai√∫sculo.
- `!r` chama o `repr()` no objeto
- `=` exibe o c√≥digo que foi executado dentro das chaves (`num = valor_de_num`)

Muita coisa nova aqui n√©? Vou detalhar tudo mais abaixo!

---

## O Operador Walrus (`:=`) em f-strings

O operador walrus (`:=`) permite atribuir valores diretamente dentro de
express√µes, e isso tamb√©m funciona dentro de f-strings.

Com ele, √© poss√≠vel fazer uma atribui√ß√£o inline e reutilizar o valor calculado
imediatamente, sem precisar declarar a vari√°vel antes do print.

No exemplo abaixo, temos uma sequ√™ncia de bytes que representa a palavra
"Ot√°vio" codificada em UTF-8. Primeiro fazemos a decodifica√ß√£o para string e, em
seguida, usamos o operador walrus dentro da f-string para atribuir esse valor a
uma vari√°vel mais curta (`v`), que pode ser reutilizada.

```python
# bytes que viram "Ot√°vio"
my_name = b'\x4f\x74\xc3\xa1\x76\x69\x6f'

# Vari√°vel super longa que precisa ser reutilizada
variavel_longa_e_chata = my_name.decode('utf-8')
# resultado: "Ot√°vio"

# Atribuindo a vari√°vel √† `v` diretamente dentro da f-string
print(f"Sa√≠da: {(v := variavel_longa_e_chata) = }")
# Sa√≠da: (v := variavel_longa_e_chata) = 'Ot√°vio'

# Agora `v` j√° existe e pode ser reutilizada normalmente
print(f"Reutilizando `v`: {v} foi muito legal. {v}")
# Sa√≠da: Reutilizando `v`: Ot√°vio foi muito legal. Ot√°vio
```

O trecho `{(v := variavel_longa_e_chata) = }` dentro da f-string faz com que o
Python exiba tanto o c√≥digo quanto o valor atribu√≠do. Isso √© especialmente √∫til
para debug, logs ou para mostrar valores intermedi√°rios sem precisar criar
vari√°veis em linhas separadas.

> Observa√ß√£o: a sequ√™ncia `\x4f\x74\xc3\xa1\x76\x69\x6f`, quando decodificada em
> UTF-8, resulta na string "Ot√°vio".

---

## Trabalhando datas e horas com `f-strings`

Vou te mostrar v√°rios exemplos para trabalhar com datas, horas, minutos,
segundos, milissegundos e microsegundos. Isso √© √∫til para praticamente todos os
casos que trabalham com datas e horas no mundo da programa√ß√£o (praticamente
tudo).

---

### Transformando segundos em H:M:S

O exemplo a seguir demonstra a formata√ß√£o de segundos em horas, minutos e
segundos usando o formato `H:M:S`.

Primeiro, vamos criar uma fun√ß√£o para facilitar as contas:

```python
def calcula_segundos_para_horas(segundos: int) -> tuple[int, int, int]:
    """
    Converte uma quantidade total de segundos em horas, minutos e segundos. Retorna uma tupla com (int, int, int)
    que podemos pegar com:
    h, min, seg = calcula_segundos_para_horas(31989)
    """
    horas = segundos // 60 // 60
    minutos = segundos // 60 % 60
    segundos = segundos % 60

    return horas, minutos, segundos
```

Agora vamos brincar com `f-strings`:

```python
# 8 horas, 53 minutos, 9 segundos
# Queremos: 08:53:09
total_de_segundos = 31989
horas, minutos, segundos = calcula_segundos_para_horas(total_de_segundos)

# Sem formata√ß√£o
print(f"Tempo: {horas}:{minutos}:{segundos}")
# Sa√≠da incorreta: Tempo: 8:53:9

# Aqui podemos usar pad (mais abaixo falamos mais sobre isso)
print(f"Tempo: {horas:02}:{minutos:02}:{segundos:02}")
# Sa√≠da correta: Tempo: 08:53:09
```

Tamb√©m podemos exibir o trecho de c√≥digo acima de outras formas. Vamos ver mais
exemplos a seguir:

```python
# Podemos brincar com isso assim:
print(f"{horas} horas, {minutos} minutos e {segundos} segundos")
# Sa√≠da: 8 horas, 53 minutos, 9 segundos
```

Voc√™ pode at√© fazer if dentro de f-string se quiser. Eu acho isso meio feio,
confuso e at√© bagun√ßado em alguns casos. Mas dependendo do que for fazer, pode
ser √∫til:

```python
# Tirei os 9 segundos do tempo total para os segundos ficarem zerados
total_de_segundos = 31980
horas, minutos, segundos = calcula_segundos_para_horas(total_de_segundos)

# Essa vari√°vel ser√° usada para exibir os segundos
texto_segundos = f', {segundos} segundos'
# S√≥ exibimos os segundos se segundos > 0
print(f"{horas} horas, {minutos} minutos{texto_segundos if segundos > 0 else ''}")
# Sa√≠da: 8 horas, 53 minutos
```

O ideal mesmo, seria criar uma fun√ß√£o para a formata√ß√£o. Assim, ficaria mais
f√°cil fazer algumas condicionais, por exemplo: `1 sugundos` ficaria bem feio,
mas nada que uma condicional n√£o resolveria.

Se voc√™ mudar as contas de uma forma que elas retornem n√∫meros de ponto
flutuante (`float`), pode fazer algo assim para omitir os valores decimais.

```python
print(f"Tempo: {horas:02.0f}:{minutos:02.0f}:{segundos:02.0f}")
```

Esse `:02.0f` significa o seguinte:

- `:` - inicia a formata√ß√£o.
- `02` - O `0` √© o valor de preenchimento (padding √† esquerda); o `2` √© quantos
  caracteres devem existir no total, contando com o valor real mais o `0`. Ex.:
  `1` se torna `01`; `32` continua sendo `32`.
- `.0f` - indica que n√£o quero nenhuma casa decimal (nem o ponto).

---

### Manipula√ß√£o de horas usando `f-string`, `datetime` e `timedelta`

Vamos gerar uma data base. N√£o estamos preocupados com a data neste momento, s√≥
queremos as horas. Por isso vou usar `datetime(1, 1, 1, 8, 23, 1)`. Isso
representa a hora `08:23:01`.

```python
from datetime import datetime

hora = datetime(1, 1, 1, 8, 23, 1)
print(f"Hora: {hora.strftime('%H:%M:%S')}")
# Sa√≠da: Hora: 08:23:01
```

**Dica:** os valores `%H`, `%M` e `%S` representam horas, minutos e segundos com
zero √† esquerda. Voc√™ pode ver todas as possibilidades
[na documenta√ß√£o do Python](https://docs.python.org/3/library/datetime.html#format-codes).

Voc√™ tamb√©m pode usar `timedelta` para somar ou subtrair o tempo desejado da
data. Isso funcionaria com uma data inteira, mas como estou focando nas horas,
vamos trabalhar somente em horas, minutos, segundos, etc...

```python
from datetime import datetime, timedelta

# Hora antiga: 00:00:00
hora_antiga = datetime(1, 1, 1, 0, 0, 0)
# Vamos somar 10:07:10 na hora antiga
tempo_adicional = timedelta(hours=10, minutes=7, seconds=10)
nova_hora = hora_antiga + tempo_adicional

# Perceba que aqui eu estou usando a pr√≥pria data
# para formatar. No pr√≥ximo exemplo, vou usar `f-string`
# apenas.
print(f"Nova hora: {nova_hora.strftime('%H:%M:%S')}")
# Sa√≠da: Nova hora: 10:07:10

# Vamos adicionar mais 10 segundos?
nova_hora += timedelta(seconds=10)

# f-strings tamb√©m podem formatar data
print(f"Nova hora: {nova_hora:%H:%M:%S}")
# Sa√≠da: Nova hora: 10:07:20
```

### Microssegundos em Milissegundos com `f-string`

Como fa√ßo v√°rios v√≠deos diariamente, trabalho bastante com fra√ß√µes de segundos
muito pequenas para alinhar legendas e transcri√ß√µes com o que √© falado do v√≠deo.
O formato de tempo usado em legendas SRT (SubRip) √© `00:00:00,000`, onde o final
`,000` s√£o milissegundos.

A ideia √© a mesma do que descrevi no t√≥pico anteriore desse texto:

```python
from datetime import datetime

# 00:02:23
tempo_do_video = datetime(1, 1, 1, 0, 2, 23)

# O formato anterior era:
# %H:%M:%S
# Agora vamos adicionar os microsegundos (%f):
# %H:%M:%S,%f
print(f"{tempo_do_video:%H:%M:%S}")
# Sa√≠da: 00:02:23
```

Os microsegundos s√£o as 3 √∫ltimas casas decimais, os milissegundos s√£o as 3
primeiras casas decimais. Vamos conferir com `timedelta`.

```python
from datetime import datetime, timedelta

# 00:02:23
tempo_do_video = datetime(1, 1, 1, 0, 2, 23)

# Os microssegundos 111 devem aparecer nos 3 √∫ltimos d√≠gitos
# depois da v√≠rgula
tempo_do_video += timedelta(microseconds=111)
print(f"{tempo_do_video:%H:%M:%S,%f}")
# Sa√≠da: 00:02:23,000111

# 00:02:23 (isso √© s√≥ pra voltar a data ao valor inicial)
tempo_do_video = datetime(1, 1, 1, 0, 2, 23)

# Os milissegundos 222 devem aparecer nos 3 primeiros d√≠gitos
# depois da v√≠rgula
tempo_do_video += timedelta(milliseconds=111)
print(f"{tempo_do_video:%H:%M:%S,%f}")
# Sa√≠da: 00:02:23,111000

# Ok, eu s√≥ quero milissegundos, portanto
print(f"{tempo_do_video:%H:%M:%S,%f}"[:-3])
# Sa√≠da: 00:02:23,111
```

O `[:-3]`significa que eu n√£o quero os 3 √∫ltimos d√≠gitos da string. Isso √©
chamado de
[fatiamento de strings, falei sobre isso aqui](https://youtu.be/QxjArQ9xZDg?si=MOxtznr0cdQQw5a1).

---

### Manipula√ß√£o de datas usando `f-string`, `datetime` e `timedelta`

S√≥ para constar, se voc√™ tem uma data inteira, √© exatamente da mesma forma que
vimos antes para formatar com `f-strings`.

```python
import locale
from datetime import datetime

# Isso serve para configurar os padr√µes culturais do pa√≠s:
# idioma, timezone, moeda, etc.
# pt_BR = Portugu√™s do Brasil
locale.setlocale(locale.LC_ALL, 'pt_BR')

# 02/12/1987 10:59:23
nascimento_joaozinho = datetime(1987, 12, 2, 10, 59, 23)

# Exemplo
print(f"{nascimento_joaozinho:%d de %B de %Y √†s %H:%M:%S}")
# Sa√≠da: 02 de Dezembro de 1987 √†s 10:59:23

# Outra exemplo
print(
    f"Jo√£ozinho nasceu no ano de {nascimento_joaozinho:%y}. "
    f"Est√°vamos no m√™s de {nascimento_joaozinho:%B}, "
    f"dia {nascimento_joaozinho:%d}. "
    f"Era um dia chuvoso. No rel√≥gio marcava "
    f"{nascimento_joaozinho:%H horas e %M minutos}."
)
# Jo√£ozinho nasceu no ano de 87.
# Est√°vamos no m√™s de Dezembro, dia 02.
# Era um dia chuvoso.
# No rel√≥gio marcava 10 horas e 59 minutos.
```

T√°, exagerei no √∫ltimo exemplo. Sorry! Mas acho que √© isso a√≠ que voc√™ vai usar
no dia a dia.

---

## Representa√ß√£o de Objetos com f-strings: `!r`, `!s`, `!a`

Dentro de uma f-string √© poss√≠vel exibir a representa√ß√£o de um objeto usando os
sufixos `!s`, `!r` ou `!a`. Eles chamam, respectivamente, as fun√ß√µes internas
`str()`, `repr()` e `ascii()` sobre o valor mostrado.

Para entender melhor, vamos usar uma classe simples e observar quais m√©todos s√£o
invocados pelo Python.

```python
class Pessoa:
    def __init__(self, nome: str, sobrenome: str, idade: int) -> None:
        self.nome = nome
        self.sobrenome = sobrenome
        self.idade = idade

    def __repr__(self) -> str:
        cls_name = self.__class__.__name__
        attrs = ", ".join(
            f"{chave}={valor!r}" for chave, valor in self.__dict__.items()
        )
        return f"{cls_name}({attrs})"

    def __str__(self) -> str:
        return f"{self.nome} {self.sobrenome}"
```

### `!s` ‚Äî exibe o resultado de `str()`

```python
pessoa = Pessoa("Luiz Ot√°vio", "Miranda", 30)

print(f"{pessoa}")      # Sa√≠da: Luiz Ot√°vio Miranda
print(f"{pessoa!s}")    # Mesma sa√≠da; !s √© sin√¥nimo de str()
```

O Python chama o m√©todo `__str__`, convertendo o objeto em uma forma pensada
para leitura humana.

### `!r` ‚Äî exibe o resultado de `repr()`

```python
print(f"{pessoa!r}")
# Sa√≠da: Pessoa(nome='Luiz Ot√°vio', sobrenome='Miranda', idade=30)
```

Aqui o m√©todo `__repr__` √© usado: ele deve gerar uma string precisa e,
idealmente, que possa recriar o objeto.

### `!a` ‚Äî exibe o resultado de `ascii()`

`ascii()` se comporta como `repr()`, mas escapa todos os caracteres fora da
tabela ASCII b√°sica usando `\x`, `\u` ou `\U`.

```python
print(f"{pessoa!a}")
# Sa√≠da: Pessoa(nome='Luiz Ot\xe1vio', sobrenome='Miranda', idade=30)
```

Note que o caractere ‚Äú√°‚Äù (c√≥digo 225) foi escapado como `\xe1`.

---

### Explorando escapes: de `√°` para `\xe1` e de volta

```python
valor = "√°"

print("\xe1")        # '\x' + e1 ‚Üí √°
print("\u00e1")      # '\u' + 00e1 ‚Üí √°
print("\U000000e1")  # '\U' + 000000e1 ‚Üí √°

# De caractere para hexadecimal:
valor_hex = hex(ord(valor))   # '0xe1'

# De hexadecimal para caractere:
print(chr(int(valor_hex, 16)))  # √°
```

Os primeiros 128 c√≥digos Unicode coincidem com os 128 caracteres ASCII
originais. Como ‚Äú√°‚Äù fica no ponto de c√≥digo 225, ele est√° fora desse intervalo ‚Äî
por isso √© escapado.

Para mergulhar mais fundo nesse assunto, confira o artigo **Normaliza√ß√£o Unicode
em Python**
([https://www.otaviomiranda.com.br/2020/normalizacao-unicode-em-python/](https://www.otaviomiranda.com.br/2020/normalizacao-unicode-em-python/)).

---

## Padding e Alinhamento de Strings e N√∫meros com f-strings

F-strings oferecem controle preciso sobre o preenchimento (padding) e o
alinhamento do texto dentro de um espa√ßo definido. Isso √© feito utilizando
especificadores de formata√ß√£o dentro das chaves `{}`, ap√≥s os dois pontos `:`.

A sintaxe geral de formata√ß√£o √© `:{fill}{align}{width}`, onde:

- `fill` (opcional): O caractere a ser usado para preencher o espa√ßo. Se
  omitido, o padr√£o √© espa√ßo (` `).
- `align` (opcional): O tipo de alinhamento.
  - `<`: Alinha o texto √† esquerda (padr√£o para strings).
  - `>`: Alinha o texto √† direita (padr√£o para n√∫meros).
  - `^`: Centraliza o texto.
- `width`: A largura total m√≠nima do campo. O texto ser√° preenchido at√© atingir
  essa largura.

Vamos ver alguns exemplos pr√°ticos de como aplicar esses especificadores:

```python
nome = "Python" # Alterado para "Python" para um exemplo mais gen√©rico

# --- Alinhamento com Espa√ßos (padding padr√£o) ---
print(f"'{nome:<15}'") # Aspas para visualizar o padding
# Alinhamento √† esquerda (padr√£o para strings), preenchido com espa√ßos at√© 15 caracteres.
# Sa√≠da: 'Python         '

print(f"'{nome:>15}'")
# Alinhamento √† direita, preenchido com espa√ßos at√© 15 caracteres.
# Sa√≠da: '         Python'

print(f"'{nome:^15}'")
# Alinhamento ao centro, preenchido com espa√ßos at√© 15 caracteres.
# Sa√≠da: '    Python     '

# Para n√∫meros, o preenchimento com '0' √† esquerda √© comum
numero_item = 7
print(f"{numero_item:03}")
# Preenchimento com '0' √† esquerda at√© 3 caracteres (√∫til para numera√ß√£o).
# Sa√≠da: 007

# Voc√™ pode usar qualquer caractere para preencher. O caractere de preenchimento vem ANTES do alinhamento.
produto_id = "ABC"
print(f"ID: {produto_id:x<10}") # Preenche com 'x' e alinha √† esquerda
# Sa√≠da: ID: ABCxxxxxxx

preco = 123.45
print(f"Pre√ßo: {preco:*>12.2f}") # Preenche com '*' e alinha √† direita, 2 casas decimais
# Sa√≠da: Pre√ßo: ******123.45

# --- Aplica√ß√£o em Cen√°rios Reais ---

# Numera√ß√£o de arquivos com zeros √† esquerda (ex: 000001.mp4)
for i in range(3):
    print(f"{i:06}.mp4")
# Sa√≠da:
# 000000.mp4
# 000001.mp4
# 000002.mp4

# Alinhamento e preenchimento combinado para um formato espec√≠fico
valor = 1048576
print(f"Resultado: {valor:!<20}")
# Preenchimento com '!' √† esquerda, alinhamento √† esquerda, largura total de 20.
# Sa√≠da: Resultado: 1048576!!!!!!!!!!!!!
```

---

## Inser√ß√£o de Express√µes e Sinais de Igual em f-strings

F-strings permitem a avalia√ß√£o direta de express√µes Python e a inclus√£o do
operador de atribui√ß√£o / sinal de igual (`=`) para _debugar_ o c√≥digo ou para
uma apresenta√ß√£o mais leg√≠vel, mostrando tanto a express√£o quanto seu resultado.

Ao inv√©s de fazer debug assim: `f'variavel = {variavel}'` para receber
`'variavel = valor'`, basta fazer assim `f'{variavel = }'` e ter√° o mesmo
resultado.

Vou te mostrar v√°rios exemplos no trecho abaixo (leia os coment√°rios).

```python
x = 3.55
y = 7.12

# Esse √© o modo que voc√™ faria isso (ANTES DO =)
print(f"{x} + {y} = {x + y}") # Sa√≠da: 3.55 + 7.12 = 10.67

# Agora com uso do sinal de igual (=) para exibir a express√£o e o resultado
# O = dentro da chave imprime "variavel=valor"
print(f"{x = }, {y = }, {x + y = }")
# Sa√≠da: x = 3.55, y = 7.12, x + y = 10.67

# Express√µes com literais (ANTES DO =)
print(f"5 * 2 = {5 * 2}") # Sa√≠da: 5 * 2 = 10

# Inser√ß√£o de vari√°veis em strings (ANTES DO =)
firstName = "Luiz Ot√°vio"
print(f"{firstName}")
# Sa√≠da: Luiz Ot√°vio

# Sinal de igual
print(f"{firstName = }")
# Sa√≠da: firstName = 'Luiz Ot√°vio'
```

---

### Conclus√£o

Este artigo explorou as diversas capacidades de formata√ß√£o de strings em Python
utilizando f-strings. Vimos desde a concatena√ß√£o b√°sica e formata√ß√£o num√©rica
com controle de casas decimais e separadores de milhares, at√© o alinhamento,
preenchimento e a poderosa avalia√ß√£o de express√µes diretamente nas strings. O
dom√≠nio das f-strings √© uma ferramenta essencial para qualquer programador
Python que busca escrever c√≥digo mais limpo, leg√≠vel e eficiente na manipula√ß√£o
de texto e dados.

Se voc√™ leu isso at√© aqui, espero que tenha aprendido muita coisa nova. Mesmo
trabalhando h√° anos com Python e programa√ß√£o em geral, ainda assim aprendo muito
escrevendo esses textos e gravando meus v√≠deos.

At√© o pr√≥ximo!!! ‚úåÔ∏è

---


    </script>
    <!-- prettier-ignore -->

    <script>
      const markdownContent =
        document.getElementById('markdown-source').textContent;
      const contentDiv = document.getElementById('content');
      contentDiv.innerHTML = marked.parse(markdownContent);
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      // Ativa o realce de sintaxe em todos os blocos de c√≥digo
      hljs.highlightAll();
    </script>

    <script src="../../js/scripts.js"></script>
  </body>
</html>
