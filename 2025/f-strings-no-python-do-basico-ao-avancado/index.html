<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>
      f-strings em Python: coisas que voc√™ n√£o sabia - Ot√°vio Miranda
    </title>
    <meta
      name="description"
      content="Uso avan√ßado de f-strings para formata√ß√£o de strings em Python, cobrindo conceitos como concatena√ß√£o, formata√ß√£o num√©rica e representa√ß√£o em diferentes bases num√©ricas."
    />

    <link rel="stylesheet" href="../../css/markdown.css" />

    <link rel="icon" type="image/webp" href="../../imgs/favicon-1.webp" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown-light.min.css"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
    />

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>
  <body>
    <nav class="breadcrumb-nav">
      <a href="/">&larr; ir para in√≠cio</a>

      <form
        id="main-search"
        action="https://www.google.com/search"
        method="get"
        target="_blank"
      >
        <input type="search" name="q" placeholder="Buscar no site via Google" />
        <button type="submit">Buscar</button>
      </form>
    </nav>

    <article class="markdown-body" id="content"></article>

    <!-- prettier-ignore -->
    <script type="text/markdown" id="markdown-source">

# f-strings em Python: coisas que voc√™ n√£o sabia

Este texto explora o uso avan√ßado das f-strings no Python, incluindo
concatena√ß√£o, formata√ß√£o num√©rica, representa√ß√£o em diferentes bases e v√°rias
outras t√©cnicas que talvez voc√™ n√£o conhe√ßa.

Eu me baseei na transcri√ß√£o do meu v√≠deo original, que voc√™ pode assistir aqui:

- <a href="https://youtu.be/yt2wPLGMAA0" target="_blank" rel="noopener noreferrer">üì∫
  f-strings em Python: coisas que voc√™ n√£o sabia ‚Üó</a>

Mas aten√ß√£o: o texto n√£o √© id√™ntico ao v√≠deo. Inclu√≠ novos exemplos de c√≥digo,
explica√ß√µes alternativas e detalhei melhor alguns t√≥picos que achei
interessantes. Espero que voc√™ goste!

**Dica importante:** coloquei MUITA coisa bacana nos coment√°rios dos exemplos de
c√≥digo, n√£o deixe de conferir.

---

## Introdu√ß√£o: concatenando strings com inteiros

Um desafio comum na programa√ß√£o √© concatenar strings com outros tipos de dados,
como inteiros. Em Python, se voc√™ tentar concatenar diretamente uma string com
um inteiro, ter√° um erro de tipo:

```python
numero = 123456789
texto = "N√∫mero: "

# Isso gera um erro: TypeError: can only concatenate str (not "int") to str
print(texto + numero)
```

Para resolver isso, voc√™ pode converter explicitamente o inteiro para string
usando a fun√ß√£o `str()`:

```python
numero = 123456789
texto = "N√∫mero: "

# Convertendo o inteiro para string antes da concatena√ß√£o
print(texto + str(numero))
# Sa√≠da: N√∫mero: 123456789
```

Mas as **f-strings** oferecem uma solu√ß√£o muito mais elegante, leg√≠vel e
eficiente para essa tarefa. Vamos conferir na pr√°tica como utilizar esse recurso
poderoso do Python!

---

## Introdu√ß√£o √†s `f-strings`

As `f-strings` (formata√ß√£o de string com prefixo `f`) oferecem uma sintaxe
concisa e poderosa para incorporar express√µes Python diretamente dentro de uma
string (`str`). Para utiliz√°-las, basta prefixar a string com `f` e envolver a
express√£o desejada entre chaves `{}`.

Exemplo b√°sico:

```python
numero = 123456789
texto = f"N√∫mero: {numero}"
print(texto) # Sa√≠da: N√∫mero: 123456789
```

Esse m√©todo funciona com strings de uma ou v√°rias linhas, com aspas simples,
duplas ou triplas.

---

## Formata√ß√£o num√©rica com f-strings

As `f-strings` facilitam muito a formata√ß√£o num√©rica, permitindo aplicar
separadores de milhares e definir facilmente quantas casas decimais voc√™ quer
exibir.

---

### Separadores de milhares

Voc√™ pode utilizar **underscores (`_`)** ou **v√≠rgulas (`,`)** ap√≥s os dois
pontos (`:`) dentro das chaves para destacar os milhares. Veja os exemplos:

```python
numero = 123456789

# Usando underscore como separador de milhares
print(f"N√∫mero com underscores: {numero:_}")  # Sa√≠da: 123_456_789

# Usando v√≠rgula como separador de milhares
print(f"N√∫mero com v√≠rgulas: {numero:,}")     # Sa√≠da: 123,456,789
```

Esses formatos deixam os n√∫meros grandes bem mais f√°ceis de ler!

---

### Definindo casas decimais com `.nf`

Para formatar n√∫meros com ponto flutuante usando `f-strings`, basta utilizar
`.nf`, onde `n` √© a quantidade desejada de casas decimais ap√≥s o ponto.

Veja os exemplos:

```python
numero_float = 198.7654321

# Limitando a duas casas decimais
print(f"Duas casas decimais: {numero_float:.2f}")  # Sa√≠da: 198.77

# Arredondando para inteiro (sem casas decimais)
print(f"Sem casas decimais: {numero_float:.0f}")   # Sa√≠da: 199

# Limitando a quatro casas decimais
print(f"Quatro casas decimais: {numero_float:.4f}")  # Sa√≠da: 198.7654
```

Com isso voc√™ consegue controlar exatamente como seu n√∫mero ser√° exibido.

---

### Combinando separador de milhares e casas decimais

Voc√™ tamb√©m pode combinar os separadores de milhares com a defini√ß√£o de casas
decimais, tudo numa √∫nica f-string. Veja o exemplo:

```python
numero_float = 19876.54321

# Separador de milhares com v√≠rgula e duas casas decimais
print(f"Formatado: {numero_float:,.2f}")  # Sa√≠da: 19,876.54
```

Essa abordagem √© especialmente √∫til em dashboards, relat√≥rios financeiros e
interfaces voltadas ao usu√°rio, tornando os valores num√©ricos bem mais leg√≠veis.

---

### Exibindo sinais (positivo e negativo)

√â poss√≠vel exibir explicitamente os sinais positivos ou negativos em n√∫meros
usando o s√≠mbolo `+`. Veja o exemplo:

```python
numero_positivo = 10
numero_negativo = -10

# Exibindo explicitamente o sinal positivo
print(f"N√∫mero positivo: {numero_positivo:+d}")  # Sa√≠da: +10

# N√∫mero negativo j√° exibe o sinal por padr√£o
print(f"N√∫mero negativo: {numero_negativo:d}")   # Sa√≠da: -10
```

> **Observa√ß√£o:** O sinal `+` for√ßa a exibi√ß√£o do sinal tamb√©m em n√∫meros
> positivos. Para negativos, o sinal aparece automaticamente.

---

### Porcentagem

Para representar n√∫meros como porcentagem, utilize o especificador `%` junto com
a quantidade desejada de casas decimais:

```python
porcentagem = 0.98

# Exibindo porcentagem com duas casas decimais
print(f"Porcentagem: {porcentagem:.2%}")  # Sa√≠da: 98.00%
```

---

### Convers√µes avan√ßadas: `bytes`, `int`, `str` e `hex`

√â poss√≠vel realizar convers√µes entre diferentes tipos, como string, inteiro,
hexadecimal, octal, bin√°rio, ASCII, bytes e outros formatos usando fun√ß√µes
internas (built-ins) do Python. Quando combinamos essas fun√ß√µes com as
`f-strings`, temos um poder imenso nas m√£os.

Al√©m disso, usando `!r` dentro das f-strings, voc√™ exibe diretamente a
representa√ß√£o interna do objeto (o mesmo que usar `repr()`).

**Importante:** Ao usar f-strings, os objetos s√£o automaticamente convertidos
para strings (`str`). Strings t√™m m√©todos especiais como `encode` para converter
em bytes, e bytes t√™m o m√©todo `decode` para voltar para string. Voc√™ pode
conferir mais detalhes sobre esse assunto no artigo:

- [Normaliza√ß√£o Unicode em Python](https://www.otaviomiranda.com.br/2020/normalizacao-unicode-em-python/)

Agora, veja na pr√°tica como converter um inteiro em hexadecimal, depois em
bytes, em string novamente, e finalmente voltar ao inteiro original. Este
exemplo combina v√°rias t√©cnicas que voc√™ pode usar em Python:

```python
# N√∫mero inteiro original
num = 255  # inteiro normal: 255

# Convertendo inteiro para hexadecimal (str)
int_to_hex = f'{num:x}'  # resultado: 'ff'

# Convertendo o hexadecimal (str) em bytes
hex_to_bytes = int_to_hex.encode('utf-8')  # resultado: b'ff'

# Convertendo bytes de volta para string
bytes_to_str = hex_to_bytes.decode('utf-8')  # resultado: 'ff'

# Finalmente, convertendo a string hexadecimal de volta para inteiro
hex_to_int = int(bytes_to_str, 16)  # resultado: 255

# Exibindo representa√ß√µes internas usando !r (repr)
print(f"{num = !r}")           # num = 255
print(f"{int_to_hex = !r}")    # int_to_hex = 'ff'
print(f"{hex_to_bytes = !r}")  # hex_to_bytes = b'ff'
print(f"{bytes_to_str = !r}")  # bytes_to_str = 'ff'
print(f"{hex_to_int = !r}")    # hex_to_int = 255

# Exemplos adicionais com :o, :b, :x e :X
print(f"Inteiro: {num = }")          # Inteiro: num = 255
print(f"Octal: {num = :o}")          # Octal: num = 377
print(f"Bin√°rio: {num = :b}")        # Bin√°rio: num = 11111111
print(f"Hexadecimal: {num = :x}")    # Hexadecimal: num = ff
print(f"HEXADECIMAL: {num = :X}")    # HEXADECIMAL: num = FF
```

Entendendo as formata√ß√µes usadas:

- `:o` exibe o valor em octal.
- `:b` exibe o valor em bin√°rio.
- `:x` exibe o valor em hexadecimal (letras min√∫sculas).
- `:X` exibe o valor em hexadecimal (letras mai√∫sculas).
- `!r` exibe a representa√ß√£o do objeto (equivalente ao `repr()`).
- `=` exibe tamb√©m a express√£o que gerou o valor dentro da f-string
  (`num = valor_de_num`).

√â bastante coisa nova, n√©? A seguir eu explico tudo isso com mais detalhes!

---

## O Operador Walrus (`:=`) em f-strings

O operador Walrus (`:=`) permite atribuir valores diretamente dentro de
express√µes, inclusive dentro de f-strings.

Com ele, voc√™ faz uma atribui√ß√£o inline e j√° reutiliza o valor calculado
imediatamente, sem precisar declarar a vari√°vel previamente.

Veja o exemplo abaixo: temos uma sequ√™ncia de bytes que representa a palavra
"Ot√°vio" codificada em UTF-8. Primeiro, decodificamos essa sequ√™ncia para uma
string. Depois, usando o operador Walrus dentro da f-string, atribu√≠mos esse
valor a uma vari√°vel mais curta (`v`), que pode ser reutilizada em seguida.

```python
# Sequ√™ncia de bytes que representa a palavra "Ot√°vio"
my_name = b'\x4f\x74\xc3\xa1\x76\x69\x6f'

# Decodificando bytes para uma vari√°vel com nome longo
variavel_longa_e_chata = my_name.decode('utf-8')  # resultado: "Ot√°vio"

# Usando operador Walrus diretamente dentro da f-string para atribuir a `v`
print(f"Sa√≠da: {(v := variavel_longa_e_chata) = }")
# Sa√≠da: (v := variavel_longa_e_chata) = 'Ot√°vio'

# Agora `v` j√° est√° dispon√≠vel para reutiliza√ß√£o
print(f"Reutilizando `v`: {v} foi muito legal. {v}")
# Sa√≠da: Reutilizando `v`: Ot√°vio foi muito legal. Ot√°vio
```

O trecho `{(v := variavel_longa_e_chata) = }` dentro da f-string exibe tanto o
c√≥digo executado quanto o valor atribu√≠do. Isso √© especialmente √∫til em debug,
logs ou simplesmente para mostrar valores intermedi√°rios sem precisar criar
vari√°veis separadas antes do print.

> **Nota:** A sequ√™ncia de bytes `\x4f\x74\xc3\xa1\x76\x69\x6f`, decodificada
> com UTF-8, forma a palavra "Ot√°vio".

---

## Trabalhando com datas e horas usando `f-strings`

A seguir vou mostrar diversos exemplos pr√°ticos sobre formata√ß√£o de datas,
horas, minutos, segundos, milissegundos e microsegundos usando f-strings. Esses
formatos s√£o √∫teis em praticamente qualquer aplica√ß√£o que envolva manipula√ß√£o de
datas e hor√°rios.

---

### Transformando segundos em horas, minutos e segundos (`H:M:S`)

Nesse exemplo, voc√™ vai aprender como formatar uma quantidade total de segundos
no formato tradicional `horas:minutos:segundos` (`H:M:S`).

Primeiro, vamos criar uma fun√ß√£o simples para fazer essa convers√£o pra gente:

```python
def calcula_segundos_para_horas(segundos: int) -> tuple[int, int, int]:
    """
    Converte uma quantidade total de segundos em horas, minutos e segundos.

    Exemplo de uso:
        h, min, seg = calcula_segundos_para_horas(31989)
    """
    horas = segundos // 60 // 60
    minutos = segundos // 60 % 60
    segundos = segundos % 60

    return horas, minutos, segundos
```

Agora, vamos brincar com as **f-strings** pra exibir o tempo formatado:

```python
# 8 horas, 53 minutos, 9 segundos
# Total desejado: 08:53:09
total_de_segundos = 31989
horas, minutos, segundos = calcula_segundos_para_horas(total_de_segundos)

# Sem formata√ß√£o (resultado incorreto visualmente)
print(f"Tempo: {horas}:{minutos}:{segundos}")
# Sa√≠da: Tempo: 8:53:9

# Com formata√ß√£o (padding com zeros √† esquerda)
print(f"Tempo: {horas:02}:{minutos:02}:{segundos:02}")
# Sa√≠da correta: Tempo: 08:53:09
```

Tamb√©m √© poss√≠vel exibir essa mesma informa√ß√£o de forma mais descritiva:

```python
# Exibindo de forma mais amig√°vel
print(f"{horas} horas, {minutos} minutos e {segundos} segundos")
# Sa√≠da: 8 horas, 53 minutos e 9 segundos
```

Voc√™ at√© pode inserir uma condicional diretamente dentro da f-string, embora, na
minha opini√£o, fique meio feio e bagun√ßado dependendo da complexidade. Por√©m, √†s
vezes pode ser √∫til:

```python
# Retirando os 9 segundos para zerar o valor
total_de_segundos = 31980
horas, minutos, segundos = calcula_segundos_para_horas(total_de_segundos)

# Criando uma string condicional para exibir segundos somente se forem maiores que zero
texto_segundos = f", {segundos} segundos"
print(f"{horas} horas, {minutos} minutos{texto_segundos if segundos > 0 else ''}")
# Sa√≠da: 8 horas, 53 minutos
```

Para situa√ß√µes mais complexas, o ideal seria criar uma fun√ß√£o de formata√ß√£o
separada, principalmente para evitar coisas estranhas como "1 segundos", que
fica bem feio, n√©?

Se suas contas eventualmente retornarem n√∫meros em ponto flutuante (`float`),
voc√™ pode formatar assim, garantindo que n√£o haver√° casas decimais:

```python
print(f"Tempo: {horas:02.0f}:{minutos:02.0f}:{segundos:02.0f}")
```

Explicando rapidamente o significado de `:02.0f`:

- `:` inicia a formata√ß√£o;
- `02` indica que o n√∫mero deve ter dois caracteres no total, preenchidos com
  zeros √† esquerda se necess√°rio (`1` vira `01`);
- `.0f` significa que n√£o desejamos nenhuma casa decimal (nem mesmo o ponto).

---

### Manipula√ß√£o de horas usando `f-string`, `datetime` e `timedelta`

Vamos criar uma data base apenas para facilitar a formata√ß√£o de horas. Neste
momento n√£o precisamos de uma data real, ent√£o vou usar algo bem simples:
`datetime(1, 1, 1, 8, 23, 1)`. Isso representa o hor√°rio `08:23:01`.

```python
from datetime import datetime

# Criando a hora base
hora = datetime(1, 1, 1, 8, 23, 1)

# Formatando com strftime()
print(f"Hora: {hora.strftime('%H:%M:%S')}")
# Sa√≠da: Hora: 08:23:01
```

**Dica:** Os valores `%H`, `%M` e `%S` representam, respectivamente, horas,
minutos e segundos com zero √† esquerda. Veja todas as op√ß√µes dispon√≠veis na
[documenta√ß√£o do Python](https://docs.python.org/3/library/datetime.html#format-codes).

Voc√™ tamb√©m pode usar `timedelta` para adicionar ou subtrair tempo facilmente.
Vamos ver isso em a√ß√£o:

```python
from datetime import datetime, timedelta

# Hora inicial: 00:00:00
hora_inicial = datetime(1, 1, 1, 0, 0, 0)

# Adicionando 10 horas, 7 minutos e 10 segundos
tempo_adicional = timedelta(hours=10, minutes=7, seconds=10)
nova_hora = hora_inicial + tempo_adicional

# Formatando com strftime()
print(f"Nova hora: {nova_hora.strftime('%H:%M:%S')}")
# Sa√≠da: Nova hora: 10:07:10

# Adicionando mais 10 segundos
nova_hora += timedelta(seconds=10)

# Formatando diretamente com f-string (sem strftime expl√≠cito)
print(f"Nova hora: {nova_hora:%H:%M:%S}")
# Sa√≠da: Nova hora: 10:07:20
```

---

### Microssegundos e milissegundos usando `f-string`

Como fa√ßo muitos v√≠deos diariamente, preciso lidar bastante com pequenas fra√ß√µes
de segundos pra sincronizar legendas e transcri√ß√µes. O formato t√≠pico usado nas
legendas SRT (SubRip) √© assim: `00:00:00,000`, onde `000` s√£o milissegundos.

A l√≥gica √© parecida com a que expliquei anteriormente. Veja na pr√°tica:

```python
from datetime import datetime

# Criando um tempo base: 00:02:23
tempo_do_video = datetime(1, 1, 1, 0, 2, 23)

# Exibindo o tempo sem microsegundos
print(f"{tempo_do_video:%H:%M:%S}")
# Sa√≠da: 00:02:23
```

Agora vamos adicionar microssegundos e milissegundos usando `timedelta`:

```python
from datetime import datetime, timedelta

# Tempo base novamente: 00:02:23
tempo_do_video = datetime(1, 1, 1, 0, 2, 23)

# Adicionando 111 microssegundos (devem aparecer nas √∫ltimas tr√™s casas)
tempo_do_video += timedelta(microseconds=111)
print(f"{tempo_do_video:%H:%M:%S,%f}")
# Sa√≠da: 00:02:23,000111

# Resetando ao valor inicial
tempo_do_video = datetime(1, 1, 1, 0, 2, 23)

# Agora adicionando 111 milissegundos (primeiras tr√™s casas ap√≥s a v√≠rgula)
tempo_do_video += timedelta(milliseconds=111)
print(f"{tempo_do_video:%H:%M:%S,%f}")
# Sa√≠da: 00:02:23,111000

# Exibindo apenas milissegundos, removendo os tr√™s √∫ltimos d√≠gitos com fatiamento
print(f"{tempo_do_video:%H:%M:%S,%f}"[:-3])
# Sa√≠da: 00:02:23,111
```

O que acontece nesse trecho `[:-3]` √© o seguinte: estou removendo as √∫ltimas 3
posi√ß√µes da string resultante, o que chamamos de
[fatiamento de strings (slicing)](https://youtu.be/QxjArQ9xZDg?si=MOxtznr0cdQQw5a1).
Isso √© bastante √∫til quando precisamos adaptar rapidamente o formato das
strings.

---

### Manipula√ß√£o de datas usando `f-string`, `datetime` e `timedelta`

S√≥ pra refor√ßar, a formata√ß√£o de datas completas usando f-strings √© exatamente
igual ao que vimos com horas. Veja alguns exemplos pr√°ticos:

```python
import locale
from datetime import datetime

# Configurando o locale para o padr√£o brasileiro (datas, n√∫meros, etc.)
locale.setlocale(locale.LC_ALL, 'pt_BR')

# Exemplo de data: 02/12/1987 √†s 10:59:23
nascimento_joaozinho = datetime(1987, 12, 2, 10, 59, 23)

# Formatando a data completa com f-string
print(f"{nascimento_joaozinho:%d de %B de %Y √†s %H:%M:%S}")
# Sa√≠da: 02 de Dezembro de 1987 √†s 10:59:23

# Outro exemplo mais detalhado
print(
    f"Jo√£ozinho nasceu no ano de {nascimento_joaozinho:%y}. "
    f"Est√°vamos no m√™s de {nascimento_joaozinho:%B}, "
    f"dia {nascimento_joaozinho:%d}. "
    f"Era um dia chuvoso, e o rel√≥gio marcava "
    f"{nascimento_joaozinho:%H horas e %M minutos}."
)
# Sa√≠da:
# Jo√£ozinho nasceu no ano de 87.
# Est√°vamos no m√™s de Dezembro, dia 02.
# Era um dia chuvoso, e o rel√≥gio marcava 10 horas e 59 minutos.
```

Ok, talvez eu tenha exagerado nesse √∫ltimo exemplo... üòÖ Mas acho que voc√™ sacou
a ideia e provavelmente √© isso que voc√™ vai usar no dia a dia.

---

## Representa√ß√£o de objetos com f-strings: `!r`, `!s`, `!a`

Dentro das f-strings voc√™ pode exibir a representa√ß√£o de um objeto usando os
sufixos `!s`, `!r` ou `!a`. Cada um chama respectivamente as fun√ß√µes internas do
Python: `str()`, `repr()` e `ascii()` sobre o valor exibido.

Para entender melhor, vamos criar uma classe simples e ver esses m√©todos em
a√ß√£o:

```python
class Pessoa:
    def __init__(self, nome: str, sobrenome: str, idade: int) -> None:
        self.nome = nome
        self.sobrenome = sobrenome
        self.idade = idade

    def __repr__(self) -> str:
        cls_name = self.__class__.__name__
        attrs = ", ".join(
            f"{chave}={valor!r}" for chave, valor in self.__dict__.items()
        )
        return f"{cls_name}({attrs})"

    def __str__(self) -> str:
        return f"{self.nome} {self.sobrenome}"
```

### Usando `!s` ‚Äî chama o m√©todo `__str__`

```python
pessoa = Pessoa("Luiz Ot√°vio", "Miranda", 30)

print(f"{pessoa}")    # Sa√≠da: Luiz Ot√°vio Miranda
print(f"{pessoa!s}")  # Mesma sa√≠da acima; !s chama explicitamente str()
```

Aqui o Python usa o m√©todo `__str__`, gerando uma vers√£o amig√°vel e leg√≠vel para
humanos.

### Usando `!r` ‚Äî chama o m√©todo `__repr__`

```python
print(f"{pessoa!r}")
# Sa√≠da: Pessoa(nome='Luiz Ot√°vio', sobrenome='Miranda', idade=30)
```

Agora o Python usa o m√©todo `__repr__`, que gera uma string detalhada e
idealmente √∫til para recriar o objeto.

### Usando `!a` ‚Äî chama o m√©todo `ascii()`

O m√©todo `ascii()` funciona como `repr()`, por√©m escapa caracteres n√£o-ASCII,
substituindo-os por sequ√™ncias especiais (`\x`, `\u` ou `\U`):

```python
print(f"{pessoa!a}")
# Sa√≠da: Pessoa(nome='Luiz Ot\xe1vio', sobrenome='Miranda', idade=30)
```

Note que o caractere ‚Äú√°‚Äù (fora do padr√£o ASCII b√°sico) foi convertido para
`\xe1`.

---

### Explorando escapes: de `√°` para `\xe1` e de volta

```python
valor = "√°"

print("\xe1")        # '\x' + e1 ‚Üí √°
print("\u00e1")      # '\u' + 00e1 ‚Üí √°
print("\U000000e1")  # '\U' + 000000e1 ‚Üí √°

# De caractere para hexadecimal:
valor_hex = hex(ord(valor))   # '0xe1'

# De hexadecimal para caractere:
print(chr(int(valor_hex, 16)))  # √°
```

Os primeiros 128 c√≥digos Unicode coincidem com os 128 caracteres ASCII
originais. Como ‚Äú√°‚Äù fica no ponto de c√≥digo 225, ele est√° fora desse intervalo ‚Äî
por isso √© escapado.

Para mergulhar mais fundo nesse assunto, confira o artigo
[normaliza√ß√£o Unicode em Python](https://www.otaviomiranda.com.br/2020/normalizacao-unicode-em-python/).

---

## Padding e Alinhamento de Strings e N√∫meros com f-strings

F-strings oferecem controle preciso sobre o preenchimento (padding) e o
alinhamento do texto dentro de um espa√ßo definido. Isso √© feito utilizando
especificadores de formata√ß√£o dentro das chaves `{}`, ap√≥s os dois pontos `:`.

A sintaxe geral de formata√ß√£o √© `:{fill}{align}{width}`, onde:

- `fill` (opcional): O caractere a ser usado para preencher o espa√ßo. Se
  omitido, o padr√£o √© espa√ßo (` `).
- `align` (opcional): O tipo de alinhamento.
  - `<`: Alinha o texto √† esquerda (padr√£o para strings).
  - `>`: Alinha o texto √† direita (padr√£o para n√∫meros).
  - `^`: Centraliza o texto.
- `width`: A largura total m√≠nima do campo. O texto ser√° preenchido at√© atingir
  essa largura.

Vamos ver alguns exemplos pr√°ticos de como aplicar esses especificadores:

```python
nome = "Python" # Alterado para "Python" para um exemplo mais gen√©rico

# --- Alinhamento com Espa√ßos (padding padr√£o) ---
print(f"'{nome:<15}'") # Aspas para visualizar o padding
# Alinhamento √† esquerda (padr√£o para strings), preenchido com espa√ßos at√© 15 caracteres.
# Sa√≠da: 'Python         '

print(f"'{nome:>15}'")
# Alinhamento √† direita, preenchido com espa√ßos at√© 15 caracteres.
# Sa√≠da: '         Python'

print(f"'{nome:^15}'")
# Alinhamento ao centro, preenchido com espa√ßos at√© 15 caracteres.
# Sa√≠da: '    Python     '

# Para n√∫meros, o preenchimento com '0' √† esquerda √© comum
numero_item = 7
print(f"{numero_item:03}")
# Preenchimento com '0' √† esquerda at√© 3 caracteres (√∫til para numera√ß√£o).
# Sa√≠da: 007

# Voc√™ pode usar qualquer caractere para preencher. O caractere de
# preenchimento vem ANTES do alinhamento.
produto_id = "ABC"
print(f"ID: {produto_id:x<10}")
# Preenche com 'x' e alinha √† esquerda
# Sa√≠da: ID: ABCxxxxxxx

preco = 123.45
print(f"Pre√ßo: {preco:*>12.2f}")
# Preenche com '*' e alinha √† direita, 2 casas decimais
# Sa√≠da: Pre√ßo: ******123.45

# Numera√ß√£o de arquivos com zeros √† esquerda (ex: 000001.mp4)
for i in range(3):
    print(f"{i:06}.mp4")
# Sa√≠da:
# 000000.mp4
# 000001.mp4
# 000002.mp4

# Alinhamento e preenchimento combinado para um formato espec√≠fico
valor = 1048576
print(f"Resultado: {valor:!<20}")
# Preenchimento com '!' √† esquerda, alinhamento √† esquerda, largura total de 20.
# Sa√≠da: Resultado: 1048576!!!!!!!!!!!!!
```

---

## Inserindo express√µes e sinal de igual (`=`) em f-strings

As f-strings permitem inserir diretamente express√µes Python no texto e, melhor
ainda, exibir automaticamente a express√£o seguida do seu resultado usando o
sinal de igual (`=`).

Por exemplo, ao inv√©s de fazer algo assim para debug:

```python
print(f"variavel = {variavel}")
```

voc√™ pode simplificar para:

```python
print(f"{variavel = }")
```

O resultado ser√° exatamente o mesmo, exibindo tanto a express√£o quanto o valor
atribu√≠do. Veja v√°rios exemplos abaixo (n√£o esque√ßa de ler os coment√°rios!):

```python
x = 3.55
y = 7.12

# Forma tradicional, sem o sinal de igual autom√°tico:
print(f"{x} + {y} = {x + y}")  # Sa√≠da: 3.55 + 7.12 = 10.67

# Forma simplificada usando "=" dentro das chaves (ideal para debug)
print(f"{x = }, {y = }, {x + y = }")
# Sa√≠da: x = 3.55, y = 7.12, x + y = 10.67

# Usando express√µes com literais diretamente:
print(f"5 * 2 = {5 * 2}")  # Sa√≠da: 5 * 2 = 10

# Exibindo o valor de uma vari√°vel diretamente:
firstName = "Luiz Ot√°vio"
print(f"{firstName}")      # Sa√≠da: Luiz Ot√°vio

# Exibindo com o sinal de igual:
print(f"{firstName = }")   # Sa√≠da: firstName = 'Luiz Ot√°vio'
```

---

### Conclus√£o

Nesse artigo, exploramos v√°rias formas poderosas de usar as f-strings em Python.
Come√ßamos com concatena√ß√£o b√°sica, passamos pela formata√ß√£o num√©rica avan√ßada
(controle de casas decimais, separadores de milhares), manipulamos datas e
horas, representamos objetos, e terminamos mostrando a avalia√ß√£o direta de
express√µes com o pr√°tico sinal de igual (`=`).

Dominar f-strings √© fundamental pra voc√™, que busca escrever c√≥digo Python mais
limpo, direto e eficiente, especialmente na hora de manipular textos e dados.

Se voc√™ chegou at√© aqui, espero de verdade que tenha aprendido coisas novas.
Mesmo eu trabalhando h√° anos com Python e programa√ß√£o, ainda aprendo muita coisa
enquanto escrevo esses textos e gravo meus v√≠deos.

At√© o pr√≥ximo artigo! ‚úåÔ∏è

---

    </script>
    <!-- prettier-ignore -->

    <script>
      const markdownContent =
        document.getElementById('markdown-source').textContent;
      const contentDiv = document.getElementById('content');
      contentDiv.innerHTML = marked.parse(markdownContent);
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      // Ativa o realce de sintaxe em todos os blocos de c√≥digo
      hljs.highlightAll();
    </script>

    <script src="../../js/scripts.js"></script>
  </body>
</html>
