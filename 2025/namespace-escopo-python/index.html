<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Escopo e Namespace em Python - Ot√°vio Miranda</title>
    <meta
      name="description"
      content="Em Python, o escopo determina a visibilidade e o tempo de vida dos nomes do seu programa, j√° o namespace √© o local onde os nomes est√£o salvos."
    />

    <link rel="stylesheet" href="../../css/markdown.css" />

    <link rel="icon" type="image/webp" href="../../imgs/favicon-1.webp" />

    <!-- Estilo escuro para markdown (GitHub dark) -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-dark.min.css"
    />

    <!-- Tema dark do highlight.js -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css"
    />
  </head>
  <body>
    <nav class="breadcrumb-nav">
      <a href="/">&larr; ir para in√≠cio</a>

      <form
        id="main-search"
        action="https://www.google.com/search"
        method="get"
        target="_blank"
      >
        <input type="search" name="q" placeholder="Buscar no site via Google" />
        <button type="submit">Buscar</button>
      </form>
    </nav>

    <article class="markdown-body" id="content"></article>

    <!-- prettier-ignore -->
    <script type="text/markdown" id="markdown-source">







<h1 id="namespace-escopo-python">
<a href="#namespace-escopo-python">
Escopo e Namespace em Python
</a>
</h1>

> **Publicado em** 26 de julho de 2025 | **Por**
> [Luiz Ot√°vio Miranda](https://www.otaviomiranda.com.br/)

Em Python, **escopo** √© o contexto onde um **nome** pode ser usado. Ele define a
regi√£o do c√≥digo, o tempo de vida e os limites de acesso desses nomes.

Durante a execu√ß√£o do seu programa, um ou mais **escopos** estar√£o ativos. Isso
determina quais nomes est√£o vis√≠veis naquele momento e quais resultar√£o em um
`NameError` se voc√™ tentar acess√°-los.

Os nomes definidos dentro de um **escopo** s√£o armazenados em um objeto chamado
**namespace**. Ele atua como um dicion√°rio, onde a **chave** √© o nome (ou
r√≥tulo) de um objeto e o **valor** √© o objeto referenciado.

Neste artigo, vamos explorar n√£o apenas o que s√£o **escopo e namespace**, mas
tamb√©m v√°rios outros temas relacionados. Ao final, voc√™ ter√° aprendido:

- O que √© **escopo**
- O que √© **namespace**
- Os tipos de escopo: **Local**, **Enclosing**, **Global** e **Built-in**
- A regra LEGB: a ordem de busca por nomes
- Como usar as palavras-chave `global` e `nonlocal` de forma consciente
- Como usar fun√ß√µes como `globals()`, `locals()`, `vars()` e `dir()` para
  inspecionar e acessar namespaces

---

<h2 id="o-que-e-escopo">
<a href="#o-que-e-escopo">
O que √© escopo?
</a>
</h2>

Quando voc√™ cria um nome em seu c√≥digo, como uma **vari√°vel**, uma **fun√ß√£o** ou
uma **classe**, ele s√≥ pode ser usado **dentro de um certo contexto**. Esse
contexto √© o que chamamos de **escopo**.

Em termos pr√°ticos, **escopo √© a regi√£o do seu c√≥digo onde um nome est√°
diretamente acess√≠vel**. Ou seja, √© onde o Python vai "procurar" por aquele nome
quando voc√™ tenta utiliz√°-lo. Se voc√™ conseguir acessar o nome solicitado,
falamos que ele est√° **no escopo**, do contr√°rio ele estar√° **fora do escopo**.

> **Nota:**: sempre que eu usar a palavra "**nome**", estou me referindo a
> identificadores como vari√°veis, classes, fun√ß√µes, m√≥dulos ou qualquer coisa
> que pode receber um **nome** em Python.

Vamos para um exemplo (sempre leia os coment√°rios de c√≥digo):

```python
x = 10  # Vari√°vel 'x' no escopo global

def mostrar():
    print(x)  # Acessa 'x' do escopo global

mostrar()
```

Nesse c√≥digo, a vari√°vel `x` foi definida no **escopo global**, fora de qualquer
fun√ß√£o. Quando `print(x)` √© chamado dentro da fun√ß√£o `mostrar()`, o Python
primeiramente busca `x` no escopo local da fun√ß√£o. Como n√£o o encontra l√°, ele
"sobe" para o escopo global, onde `x` est√° dispon√≠vel.

Mas onde o Python guarda esse nome `x` com o valor `10`?

√â nesse ponto que os **namespaces** entram em cena: **todo escopo possui seu
pr√≥prio "espa√ßo de nomes"**, um local onde os nomes e seus respectivos objetos
s√£o armazenados. Vamos explorar isso em detalhes a seguir.

---

<h2 id="o-que-e-namespace">
<a href="#o-que-e-namespace">
O que √© namespace?
</a>
</h2>

Um **namespace** √©, essencialmente, uma **estrutura que mapeia nomes a
objetos**. Voc√™ pode pensar nele como um dicion√°rio onde cada **chave** √© o nome
que voc√™ define (como o nome de uma vari√°vel, fun√ß√£o ou classe) e o **valor** √©
o objeto correspondente no seu c√≥digo.

Sempre que voc√™ cria um nome em Python, essa associa√ß√£o √© guardada dentro de um
namespace. Algumas das formas mais comuns de criar nomes incluem:

- **Atribui√ß√£o:** `variavel = valor`
- **Importa√ß√£o:** `import modulo` ou `from modulo import objeto`
- **Defini√ß√£o de fun√ß√µes:** `def minha_funcao(): ...`
- **Argumentos de fun√ß√µes:** `def outra_funcao(arg1, arg2): ...`
- **Defini√ß√£o de classes:** `class MinhaClasse: ...`

> **Nota:** existem diferen√ßas entre opera√ß√µes de atribui√ß√£o (criar ou modificar
> um valor) e opera√ß√µes de acesso (apenas ler um valor). Vamos falar sobre isso
> nesse artigo na se√ß√£o
> "[global e nonlocal - alterando nomes fora do escopo](#global-nonlocal-324)".

Todos esses exemplos resultam na cria√ß√£o de nomes dentro do **namespace** ativo
no momento da sua defini√ß√£o.

Cada namespace est√° diretamente ligado a um **escopo**, que determina onde e
quando aquele nome estar√° dispon√≠vel durante a execu√ß√£o do seu c√≥digo.

Embora voc√™ possa inspecionar namespaces usando fun√ß√µes como `globals()` e
`locals()` (que retornam representa√ß√µes em dicion√°rio), isso √© mais comum para
introspec√ß√£o de c√≥digo ou fins did√°ticos do que para o uso di√°rio.

Existem diferentes tipos de namespaces em Python, cada um com sua finalidade:

- **Global:** Cada m√≥dulo Python possui um namespace global, que armazena os
  nomes definidos diretamente na sua raiz, fora de fun√ß√µes ou classes.
- **Local:** Cada vez que uma fun√ß√£o √© chamada, um namespace local √© criado para
  ela. Ele existe apenas enquanto a fun√ß√£o est√° em execu√ß√£o e cont√©m as
  vari√°veis e argumentos definidos dentro dela.
- **Built-in:** Este namespace cont√©m os nomes de todas as fun√ß√µes e exce√ß√µes
  nativas do Python, como `print()`, `len()`, `str()`, etc. Ele √© carregado
  automaticamente.
- **Enclosing (N√£o-local):** Quando uma fun√ß√£o √© definida dentro de outra, a
  fun√ß√£o interna pode acessar os nomes do namespace da fun√ß√£o externa. Este atua
  como um escopo "intermedi√°rio" entre o local e o global.
- **Classes:** O corpo de uma classe tamb√©m forma seu pr√≥prio namespace, onde os
  atributos e m√©todos da classe s√£o definidos. √â por isso que voc√™ acessa
  membros da classe usando a nota√ß√£o de ponto (`objeto.atributo`).

√â importante notar que os namespaces de fun√ß√µes (Local e Enclosing) s√£o criados
dinamicamente no momento da execu√ß√£o. Quando uma fun√ß√£o √© chamada, o
interpretador Python gera um **Frame de Execu√ß√£o** (ou Stack Frame) que
encapsula as vari√°veis locais, par√¢metros e outras informa√ß√µes necess√°rias para
aquela chamada espec√≠fica. A fun√ß√£o `locals()` pode ser usada dentro de uma
fun√ß√£o para acessar seu namespace local.

Uma caracter√≠stica fundamental √© que **todos os namespaces s√£o independentes
entre si**. Por exemplo, voc√™ pode ter uma fun√ß√£o chamada `processar()` em dois
m√≥dulos diferentes (`modulo1.py` e `modulo2.py`). N√£o haver√° conflito, pois cada
uma reside em seu pr√≥prio namespace. Para acess√°-las, basta prefixar com o nome
do m√≥dulo: `modulo1.processar()` e `modulo2.processar()`.

---

### `globals()` e `locals()` para inspe√ß√£o de namespaces

As fun√ß√µes `globals()` e `locals()` s√£o ferramentas valiosas para inspecionar
namespaces em tempo de execu√ß√£o:

- [`globals()`](https://docs.python.org/3/library/functions.html#globals):
  Retorna um dicion√°rio que representa o **namespace global** do m√≥dulo atual.
  Isso inclui todos os nomes definidos na raiz do arquivo.
- [`locals()`](https://docs.python.org/3/library/functions.html#locals): Retorna
  um dicion√°rio com os nomes definidos no **escopo local** onde a fun√ß√£o est√°
  sendo executada. **Importante**: ela s√≥ inclui nomes que j√° foram definidos
  _antes_ da sua chamada, ent√£o geralmente √© melhor cham√°-la no final do bloco.

Vejamos um exemplo pr√°tico:

```python
# Escopo global

def show_namespace() -> None:
    # Escopo local
    module_namespace = globals()
    print("Conte√∫do de globals():", module_namespace)

    # Note que 'function_namespace' n√£o aparecer√° no locals() se chamado antes dela
    function_namespace = locals()
    print("Conte√∫do de locals():", function_namespace)


if __name__ == "__main__":
    show_namespace()
```

A sa√≠da de `globals()` ser√° algo parecido com:

```python
{
    '__name__': '__main__',
    '__doc__': None,
    # ... outras chaves padr√£o do m√≥dulo
    '__builtins__': <module 'builtins' (built-in)>,
    'show_namespace': <function show_namespace at 0x...> # Nossa fun√ß√£o
}
```

J√° a sa√≠da de `locals()` mostrar√°:

```python
{
    'module_namespace': {...} # O dicion√°rio retornado por globals()
}
```

Alguns pontos a destacar nessa sa√≠da:

- `__name__`: Indica o nome do m√≥dulo. Se for o script principal, ser√°
  `__main__`.
- `__builtins__`: Refer√™ncia ao namespace com as fun√ß√µes nativas do Python.
- `show_namespace`: O nome da nossa fun√ß√£o, definida no escopo global.

---

### `vars()` e `dir()` - Outras formas de inspecionar

Al√©m de `globals()` e `locals()`, `vars()` e `dir()` tamb√©m permitem inspecionar
nomes, mas com algumas diferen√ßas importantes:

- [`vars()`](https://docs.python.org/3/library/functions.html#vars): Retorna o
  atributo `__dict__` de um objeto, que √© onde seus atributos s√£o armazenados.
  Se chamada sem argumentos, `vars()` se comporta exatamente como `locals()`,
  retornando o namespace local.
- [`dir()`](https://docs.python.org/3/library/functions.html#dir): Sem
  argumentos, `dir()` lista todos os nomes dispon√≠veis no escopo atual. Com um
  objeto como argumento, tenta listar todos os nomes acess√≠veis nele (como
  m√©todos e atributos). Note que `dir()` retorna apenas os _nomes_, n√£o os
  objetos ou seus valores.

Vamos ver com um exemplo:

```python
def ver_namespace_local():
    var_local = "vari√°vel local"

    print("\nDENTRO DA FUN√á√ÉO (ESCOPO LOCAL)")
    print("Sa√≠da de vars():", vars())
    print("Sa√≠da de dir():", dir())


print("FORA DA FUN√á√ÉO (ESCOPO GLOBAL)")
print("Sa√≠da de vars():", vars())
print("Sa√≠da de dir():", dir())

ver_namespace_local()
```

Sa√≠da de exemplo:

```python
# FORA DA FUN√á√ÉO (ESCOPO GLOBAL)
# Sa√≠da de vars():
{
    # ... omitidos outros resultados globais
    'ver_namespace_local': <function ver_namespace_local at 0x...>
}
# Sa√≠da de dir():
[
    '__annotations__', '__builtins__', '__cached__', '__doc__',
    '__file__', '__loader__', '__name__', '__package__', '__spec__',
    'ver_namespace_local' # Nossa fun√ß√£o global
]

# DENTRO DA FUN√á√ÉO (ESCOPO LOCAL)
# Sa√≠da de vars():
{
    'var_local': 'vari√°vel local'
}
# Sa√≠da de dir():
['var_local']
```

Como pode ver, quando usadas sem argumentos, `vars()` e `dir()` se assemelham a
`locals()` e `globals()` no que diz respeito ao escopo atual. A grande diferen√ßa
√© que **`vars()` e `dir()` s√£o mais vers√°teis**, pois podem receber um objeto
como argumento, permitindo inspecionar namespaces de m√≥dulos importados,
inst√¢ncias de classe e outros objetos.

---

<h2 id="regra-legb-py">
<a href="#regra-legb-py">
Regra LEGB - Local, Enclosing, Global e Built-In
</a>
</h2>

Em Python, √© bem comum ter um escopo dentro do outro, pense em fun√ß√µes dentro de
m√≥dulos, ou at√© mesmo fun√ß√µes aninhadas dentro de outras fun√ß√µes.

Quando isso acontece e voc√™ tenta acessar um nome (como uma vari√°vel ou fun√ß√£o),
o interpretador precisa de uma ordem clara para encontr√°-lo, dependendo do ponto
em que voc√™ est√° no c√≥digo.

Essa ordem √© definida pela regra **LEGB**. Sempre que voc√™ referencia um nome,
seja para leitura, escrita ou execu√ß√£o (tipo `x` ou `print()`), o Python o busca
sequencialmente, do escopo mais interno para o mais externo:

- **Local (L):** Primeiro, o Python procura no escopo da **fun√ß√£o atual** onde o
  nome est√° sendo referenciado. Este √© o ambiente mais imediato.
- **Enclosing (E) / N√£o-Local:** Se o nome n√£o for encontrado localmente, a
  busca avan√ßa para o escopo das **fun√ß√µes que envolvem a fun√ß√£o atual** (se
  houver). Pense nisso como o escopo "da fun√ß√£o de fora".
- **Global (G):** Caso o nome ainda n√£o seja encontrado, o Python ent√£o procura
  no **escopo do m√≥dulo atual**. Este √© o n√≠vel superior do seu arquivo Python.
- **Built-in (B):** Por √∫ltimo, a busca chega ao escopo `built-in`, que cont√©m
  todos os nomes nativos do Python, como fun√ß√µes (`len()`, `print()`) e exce√ß√µes
  (`NameError`).

Se o nome n√£o for encontrado em nenhum desses escopos, o Python levanta uma
exce√ß√£o `NameError`, indicando que o nome n√£o foi definido ou n√£o est√° acess√≠vel
no contexto atual.

Para visualizar como esses escopos se aninham, imagine a seguinte representa√ß√£o:

```text
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
 ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ   ‚îÇ
 ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ   ‚îÇ   ‚îÇ
 ‚îÇ ‚îÇ ‚îÇ ‚îÇ L‚Üí‚îÇ ‚Üí ‚îÇ ‚Üí ‚îÇ ‚Üí ‚îÇ # Local (L): Onde voc√™ est√° agora, o mais interno
 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ   ‚îÇ   ‚îÇ
 ‚îÇ ‚îÇ ‚îÇ       E‚Üí‚îÇ ‚Üí ‚îÇ ‚Üí ‚îÇ # Enclosing (E): A fun√ß√£o que envolve a sua fun√ß√£o
 ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ   ‚îÇ
 ‚îÇ ‚îÇ             G‚Üí‚îÇ ‚Üí ‚îÇ # Global (G): O m√≥dulo inteiro do seu arquivo
 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
 ‚îÇ                  B‚Üí‚úò‚îÇ # Built-in (B): Mais externo, tudo do Python
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Se preferir, preparei uma imagem tamb√©m para te ajudar a entender melhor.

<p align="center"><img 
 src='images/python-legb-rule.webp'
 alt='Diagrama mostrando a regra LEGB do Python' 
/></p>

A seguir, vamos ver exemplos de c√≥digo para tornar cada um desses escopos
cristalino.

---

### A regra LEGB em a√ß√£o

Para entender a **regra LEGB** na pr√°tica, vamos usar um c√≥digo simples e
observar como o Python busca os nomes em cada escopo. Usei bastante os
coment√°tios do c√≥digo para detalhar melhor o que est√° acontecendo.

```python
# Escopo do m√≥dulo: Global (G)
var_global = "Estou no escopo global!"

def funcao_externa() -> None:
    # Escopo da fun√ß√£o: Local (L) para esta fun√ß√£o
    var_local = "Estou no escopo local!"

    # Busca de 'var_local':
    # O Python encontra 'var_local' no escopo Local (L).
    print(var_local)

    # Busca de 'var_global':
    # N√£o encontra 'var_global' no Local (L), ent√£o busca no Global (G).
    print(var_global)

    # Busca de 'print':
    # N√£o encontra 'print' em L ou G, ent√£o busca no Built-in (B).
    print(print) # Imprime a representa√ß√£o da pr√≥pria fun√ß√£o print


if __name__ == "__main__":
    funcao_externa()
```

Analisando o fluxo de busca de nomes nesse exemplo, o Python segue a regra LEGB
(sempre do mais interno ao mais externo):

- **`var_local`**: Encontrado diretamente no escopo **L**ocal da
  `funcao_externa`. Trajeto: **L**.
- **`var_global`**: N√£o encontrado em **L**, a busca sobe para o escopo
  **G**lobal. Trajeto: **L ‚Üí G**.
- **`print`**: N√£o encontrado em **L** nem em **G**, a busca atinge o escopo
  **B**uilt-in. Trajeto: **L ‚Üí G ‚Üí B**.

√â fundamental entender que essa busca √© sempre **unidirecional: de dentro para
fora**. Escopos mais internos conseguem "enxergar" os nomes definidos nos
escopos mais externos (que os cont√™m), mas o contr√°rio n√£o √© verdadeiro.

Veja um exemplo cl√°ssico de `NameError` que prova isso:

```python
def funcao_interna():
    mensagem = "Ol√° do escopo local!"

# Erro! 'mensagem' s√≥ existe dentro de 'funcao_interna'
print(mensagem)
# Sa√≠da esperada: NameError: name 'mensagem' is not defined
```

A mensagem de erro `NameError: name 'mensagem' is not defined` ocorre porque, no
escopo global, o Python n√£o consegue "descer" para o escopo local de
`funcao_interna` para encontrar `mensagem`.

> **Em resumo: a regra LEGB √© uma escada de subida. Voc√™ s√≥ v√™ os andares acima
> ou o seu pr√≥prio. Nunca consegue ver o que est√° nos andares abaixo do seu.**

---

### Keywords n√£o seguem a LEGB!

√â importante diferenciar nomes de **keywords** (palavras-chave). Termos como
`def`, `if`, `for`, `while`, `return`, `True`, `False`, `None` e `import` s√£o
partes da gram√°tica do Python, n√£o nomes.

Por serem palavras reservadas, elas **n√£o pertencem a nenhum namespace** e,
consequentemente, **n√£o seguem a regra LEGB**. Tentar us√°-las como vari√°veis
resultar√° em um erro de sintaxe (`SyntaxError`) no momento da an√°lise do c√≥digo,
antes mesmo da execu√ß√£o:

```python
# Isso vai causar um SyntaxError!
# Esse c√≥digo nem chega a rodar
def = 10
```

Se quiser ver a lista completa de palavras-chave reservadas, execute o comando
abaixo no seu terminal Python:

```bash
python -c "help('keywords')"
```

Isso mostrar√° a lista das `keywords` do Python, como `False`, `True`, `None`,
`and`, `as`, `assert`, `break`, `class`, etc. (Existem tamb√©m as _soft
keywords_, mas isso fica para outra conversa).

---

<h2 id="local-enclosing-879">
<a href="#local-enclosing-879">
Enclosing - entenda o escopo aninhado
</a>
</h2>

Enquanto os escopos **Global**, **Local** e **Built-in** costumam ser mais
intuitivos, o escopo **Enclosing** gera mais d√∫vidas porque ele s√≥ aparece em um
cen√°rio espec√≠fico: quando temos **fun√ß√µes aninhadas**, ou seja, uma fun√ß√£o
definida dentro de outra. Vamos focar nele agora.

Considere este c√≥digo:

```python
def funcao_externa():
    # 'var_enclosing' √© local para 'funcao_externa'
    # e Enclosing para 'funcao_interna'
    var_enclosing = "Eu sou do escopo enclosing!"

    def funcao_interna():
        # 'var_local' est√° no escopo Local de 'funcao_interna'
        var_local = "Eu sou do escopo local!"

        # Acessando 'var_local' (L) e 'var_enclosing' (E)
        print(var_local, var_enclosing)

    # Chamamos a fun√ß√£o interna para execut√°-la
    funcao_interna()

funcao_externa()
# Sa√≠da esperada: Eu sou do escopo local! Eu sou do escopo enclosing!
```

Como voc√™ pode ver na sa√≠da, a `funcao_interna()` consegue acessar tanto
`var_local` (que est√° em seu escopo **L**ocal) quanto `var_enclosing` (que est√°
no escopo **E**nclosing, da `funcao_externa`). Isso acontece exatamente por
causa da regra **LEGB**: o Python busca os nomes de dentro para fora,
encontrando `var_enclosing` no n√≠vel acima.

Por outro lado, a `funcao_externa()` **n√£o tem acesso direto** a `var_local`,
pois `var_local` reside em um escopo mais interno que o dela. Da mesma forma, o
escopo global n√£o consegue acessar nenhuma das vari√°veis definidas dentro de
`funcao_externa` ou `funcao_interna`.

---

### Call stack e o tempo de vida dos escopos

A raz√£o para esse comportamento reside em como o Python gerencia a execu√ß√£o de
fun√ß√µes utilizando a **call stack** (pilha de chamadas).

Sempre que uma fun√ß√£o √© chamada, o Python cria um **frame de execu√ß√£o** (ou
_stack frame_) para ela. Esse frame √© empilhado no topo da call stack, que
funciona no esquema LIFO (Last-In, First-Out: o √∫ltimo que entra √© o primeiro
que sai). Apenas o frame no topo da pilha est√° ativo. Quando a fun√ß√£o termina
sua execu√ß√£o, seu frame √© **descartado** da pilha, e o Python retorna o controle
para o frame anterior. √â por isso que o escopo local de uma fun√ß√£o s√≥ "existe"
enquanto ela est√° em execu√ß√£o.

<p align="center">
<img src='images/call-stack-example.webp' alt='Exemplo da call stack do Python em execu√ß√£o' />
</p>

A imagem acima ilustra a call stack em a√ß√£o. O √≠cone do Python indica a posi√ß√£o
atual do interpretador. As **setas vermelhas** (`--->`) representam o **fluxo de
execu√ß√£o** e a cria√ß√£o/remo√ß√£o de frames na pilha. As **setas amarelas** (`‚Üì`)
mostram a **dire√ß√£o de busca de nomes** de acordo com a regra LEGB (do escopo
mais interno para o mais externo).

Observe o fluxo na imagem:

1.  A execu√ß√£o inicia no `mod.py` (escopo Global).
2.  Ao chamar `funcao_externa()`, um novo frame √© empilhado. O interpretador se
    move para dentro dela.
3.  Dentro de `funcao_externa()`, ao chamar `funcao_interna()`, outro frame √©
    empilhado, e o interpretador se move para l√°.
4.  Quando `funcao_interna()` termina, seu frame √© desempilhado, e o controle
    retorna para `funcao_externa()`.
5.  Finalmente, `funcao_externa()` termina, seu frame √© desempilhado, e a
    execu√ß√£o retorna ao `mod.py` (escopo global), concluindo o processo.

Esse mecanismo √© fundamental para a organiza√ß√£o e o isolamento do c√≥digo:

- Voc√™ consegue acessar nomes definidos em escopos mais externos (Globais,
  Enclosing) a partir de dentro de uma fun√ß√£o.
- Mas **n√£o consegue acessar nomes definidos dentro de fun√ß√µes estando fora
  delas**, porque o escopo local de uma fun√ß√£o **deixa de existir** (√©
  descartado) assim que ela termina de executar.

Para um aprofundamento sobre a call stack e fun√ß√µes, especialmente em cen√°rios
como recurs√£o, recomendo este material:

- [Fun√ß√µes recursivas com Python](https://www.otaviomiranda.com.br/2020/funcoes-recursivas-com-python/)

Agora que entendemos o Enclosing e o que acontece por baixo dos panos, podemos
continuar.

---

<h2 id="global-nonlocal-324">
<a href="#global-nonlocal-324">
global e nonlocal - Alterando nomes fora do escopo atual
</a>
</h2>

Nas se√ß√µes anteriores, focamos em como os nomes s√£o **acessados (lidos)** de um
escopo em outro, um processo que tende a ser mais direto.

No entanto, a tentativa de **alterar** um nome que n√£o foi definido no escopo
atual gera uma ambiguidade para o interpretador. Como ele saberia se voc√™ quer
criar um **novo nome local** (com o mesmo r√≥tulo) ou **modificar o nome
existente** em um escopo externo? Essa √© a quest√£o.

Essa ambiguidade surge justamente pela flexibilidade que o Python oferece: a
capacidade de ter nomes iguais em escopos diferentes sem que um afete o outro, a
menos que voc√™ explicitamente pe√ßa.

Mas... antes de mergulharmos nas solu√ß√µes, uma pausa para as **boas pr√°ticas**.

---

### Devo alterar nomes fora de seu escopo imediato?

A principal fun√ß√£o do escopo e do namespace √© **proteger nomes de altera√ß√µes
acidentais** e garantir o isolamento do c√≥digo. Fazer altera√ß√µes intencionais em
nomes que residem fora do escopo imediato vai, em certa medida, contra essa
ideia central.

Vou listar alguns problemas que essa pr√°tica pode gerar (e a lista √© bem maior):

- **Dificulta o Debug:** Rastrear a origem de um bug se torna um pesadelo quando
  vari√°veis s√£o alteradas de forma "m√°gica" em diferentes partes do c√≥digo.
- **Dificulta Testes:** Fun√ß√µes que dependem ou alteram o estado global s√£o mais
  complexas de testar isoladamente, exigindo um setup e cleanup maiores.
- **Reduz a Legibilidade e Manuten√ß√£o:** O c√≥digo fica menos intuitivo, exigindo
  que o leitor "pule" entre escopos para entender o fluxo de dados.
- **Aumenta o Acoplamento:** M√≥dulos e fun√ß√µes se tornam mais interdependentes,
  tornando o sistema mais r√≠gido e dif√≠cil de refatorar.
- **Problemas em Concorr√™ncia:** Em ambientes multi-thread ou ass√≠ncronos, a
  altera√ß√£o de estado global pode levar a _race conditions_ e bugs extremamente
  dif√≠ceis de diagnosticar.
- **Contraria Paradigmas Comuns:** Vai contra princ√≠pios de paradigmas como
  programa√ß√£o funcional (que preza imutabilidade) e orienta√ß√£o a objetos (que
  encapsula estado).

Se voc√™ se encontrar na situa√ß√£o de precisar alterar o valor de uma vari√°vel
fora do seu escopo imediato, **pare e reavalie a sua solu√ß√£o**. Quase sempre h√°
uma forma mais elegante e segura de resolver o problema, como passar os valores
via argumentos ou retornar novos valores.

Ok, com essa ressalva importante em mente, agora sim vamos entender como
`global` e `nonlocal` funcionam para alterar vari√°veis fora do seu escopo local.

---

### `global` - alterando nomes no escopo global

Vamos analisar o comportamento padr√£o quando tentamos alterar uma vari√°vel
global dentro de uma fun√ß√£o. Acompanhe o c√≥digo e o erro que ele gera:

```python
# Escopo global (G)
variavel = "global"

def funcao():
    # Tentativa de usar `variavel` (G)
    print(variavel) # <-- ISSO VAI GERAR O ERRO

    # Criei um novo nome `variavel` no escopo LOCAL (L)
    # Isso fez o nome `variavel` deixar de existir no print acima
    variavel = "local" # <-- ESSE √â O MOTIVO DO ERRO

    # Agora, estamos tentando usar a `variavel` LOCAL
    print(variavel)

funcao() # <-- O interpretador n√£o passa daqui
print(variavel)
# A `variavel` global original permanece inalterada
```

Ao executar `funcao()`, voc√™ receber√° um `UnboundLocalError`:

```
UnboundLocalError: cannot access local variable 'variavel'
where it is not associated with a value
```

O interpretador Python √© inteligente: ao ver a linha `variavel = "local"` dentro
da fun√ß√£o, ele assume que `variavel` ser√° uma **vari√°vel local** para
`funcao()`. Portanto, quando `print(variavel)` √© chamado _antes_ dessa
atribui√ß√£o local, Python busca por `variavel` no escopo local, encontra uma
refer√™ncia de atribui√ß√£o futura, mas percebe que ela ainda n√£o tem um valor
associado **dentro daquele escopo local**. Isso causa o `UnboundLocalError`.

Para informar ao Python que voc√™ deseja modificar a vari√°vel `variavel` que
reside no escopo **global**, utilizamos a palavra-chave `global`:

```python
variavel = "global"

def funcao():
    # 'global variavel' informa ao interpretador
    # que estamos referenciando e modificando a vari√°vel global.
    global variavel

    # Agora, podemos usar a vari√°vel global ANTES de alter√°-la
    print(variavel) # Sa√≠da: global

    # Esta atribui√ß√£o agora modifica a vari√°vel global
    variavel = "local"
    print(variavel) # Sa√≠da: local

funcao()
print(variavel) # Sa√≠da: local (o valor global foi alterado com sucesso)
```

Com `global variavel`, a primeira chamada a `print(variavel)` acessa o valor
"global". Em seguida, a linha `variavel = "local"` realmente altera a `variavel`
do escopo global.

**Importante:** A declara√ß√£o `global` deve ser feita para **cada vari√°vel
global** que voc√™ pretende alterar dentro de **cada fun√ß√£o** onde essa altera√ß√£o
ocorrer√°.

Finalmente, vale ressaltar que `global` **s√≥ funciona para nomes no escopo
global**. Se voc√™ precisar alterar um nome em um escopo `Enclosing` (n√£o-local),
voc√™ precisar√° usar outra palavra-chave do Python: `nonlocal`.

---

### `nonlocal`: alterando nomes do escopo enclosing

A palavra-chave `nonlocal` tem uma fun√ß√£o similar a `global`, mas atua no escopo
**Enclosing** (o `E` da regra LEGB), ou seja, em vari√°veis de fun√ß√µes externas
que envolvem a fun√ß√£o atual, mas que **n√£o s√£o o escopo global**.

Isso √© particularmente √∫til em cen√°rios onde uma fun√ß√£o interna precisa
modificar uma vari√°vel definida na fun√ß√£o que a cont√©m.

Veja o exemplo a seguir com apenas dois n√≠veis de aninhamento:

```python
def soma_mais_um():
    # 'numero' est√° no escopo Enclosing para 'incrementa'
    numero = 0

    def incrementa():
        # 'nonlocal numero' informa que queremos modificar
        # o 'numero' do escopo Enclosing (soma_mais_um)
        nonlocal numero
        numero += 1
        print(f"N√∫mero atual (interno): {numero}")

    # At√© aqui, nada alterado
    print(f"N√∫mero inicial (externo): {numero}")

    incrementa() # A altera√ß√£o ocorre aqui
    print(f"N√∫mero final (externo): {numero}")

soma_mais_um()
# Sa√≠da esperada:
# N√∫mero inicial (externo): 0
# N√∫mero atual (interno): 1
# N√∫mero final (externo): 1
```

Neste exemplo, a fun√ß√£o `incrementa()` consegue modificar a vari√°vel `numero`
que pertence √† `soma_mais_um()`, no seu escopo `Enclosing`. Se `nonlocal numero`
n√£o fosse usado, `incrementa()` criaria sua pr√≥pria vari√°vel local `numero`, sem
afetar a de fora.

**Cuidado com a complexidade:** Embora `nonlocal` seja uma ferramenta poderosa e
frequentemente usada em padr√µes como _closures_ e _decorators_, o aninhamento
excessivo de fun√ß√µes e o uso indiscriminado de `nonlocal` podem levar a um
c√≥digo dif√≠cil de ler e depurar. Como j√° mencionado na se√ß√£o de boas pr√°ticas,
sempre reavalie se h√° uma forma mais clara de estruturar seu c√≥digo.

---

### Concluindo - agora voc√™ passou de n√≠vel üòÅ

E assim chegamos ao fim do nosso texto sobre os conceitos de **escopo** e
**namespace** em Python. Embora esse assunto possa parecer muito abstrato, ele
acaba sendo um dos pontos principais para compreender como o Python funciona. Na
verdade, n√£o s√≥ Python! Muitas outras linguagens funcionam de maneira muito
similar. Voc√™ vai levar esse conhecimento para todas elas.

Revisamos que:

- Um **escopo** define o local do c√≥digo onde um nome estar√° vis√≠vel e
  acess√≠vel.
- Um **namespace** √© a estrutura que armazena essas associa√ß√µes entre nomes e
  objetos.
- **Escopo** e **Namespace** s√£o dois assuntos conectados em Python
- A **regra LEGB** (Local, Enclosing, Global, Built-in) √© a ordem pela qual o
  Python busca por nomes, sempre de dentro para fora.
- Vimos como as fun√ß√µes `globals()`, `locals()`, `vars()` e `dir()` podem nos
  ajudar a inspecionar esses "dicion√°rios" de nomes em tempo real.
- E, finalmente, aprendemos sobre as palavras-chave `global` e `nonlocal`, que
  nos permitem, quando necess√°rio e com muita cautela, alterar nomes em escopos
  externos ao imediato.

Dominar esses conceitos n√£o √© apenas sobre "saber o que acontece", mas sobre
**entender por que seu c√≥digo se comporta como se comporta**, evitar erros
comuns como o `UnboundLocalError`, e escrever um c√≥digo mais robusto e
previs√≠vel.

Lembre-se sempre da li√ß√£o sobre as **boas pr√°ticas**: alterar nomes fora do seu
escopo imediato deve ser a exce√ß√£o, n√£o a regra. Priorize a clareza, o baixo
acoplamento e a previsibilidade do seu c√≥digo.

Com essa base s√≥lida sobre escopo e namespace, voc√™ est√° pronto para mergulhar
em t√≥picos mais avan√ßados do Python, como _closures_ e _decorators_, que
dependem diretamente desse entendimento. Continue praticando e experimentando!

---








    </script>
    <!-- prettier-ignore -->

    <!-- Markdown parser -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"
    ></script>
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"
    ></script>
    <script defer src="../../js/scripts.js"></script>
  </body>
</html>
