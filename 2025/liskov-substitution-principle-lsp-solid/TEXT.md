<h1 id="liskov-substitution-principle-lsp-into">
<a href="#liskov-substitution-principle-lsp-into">
O Princ√≠pio da Substitui√ß√£o de Liskov (LSP)
</a>
</h1>

> **Publicado em** 12 de agosto de 2025 | **Por**
> [Luiz Ot√°vio Miranda](https://www.otaviomiranda.com.br/)

Quem j√° trabalhou com heran√ßa na programa√ß√£o orientada a objetos, muito provavelmente tamb√©m j√°
ouviu falar sobre o **Princ√≠pio da Substitui√ß√£o de Liskov**, ou at√© j√° sofreu na pr√°tica quando
ele foi quebrado no seu programa.

Introduzido
[por Barbara Liskov em 1987](https://en.wikipedia.org/wiki/Liskov_substitution_principle), o LSP √©
um dos cinco princ√≠pios do famoso **SOLID** e define uma regra simples, mas muito poderosa: _um
subtipo deve poder substituir seu tipo base sem que o comportamento esperado do sistema mude_.

Parece simple e extremamente √≥bvio, mas n√£o √©. O que muita gente esquece √© que n√£o basta a tipagem
funcionar, o **comportamento** (a sua l√≥gica) tamb√©m precisa ser compat√≠vel. √â aqui que entram
conceitos como **pr√©-condi√ß√µes**, **p√≥s-condi√ß√µes** e **invariantes**: tr√™s pilares que ajudam a
identificar se um subtipo realmente respeita o contrato definido pela superclasse.

Neste artigo, vamos entender a defini√ß√£o formal do LSP, traduzi-la para um contexto mais pr√°tico e
analisar exemplos, desde os cl√°ssicos, at√© situa√ß√µes sutis que passam despercebidas por type
checkers, mas que podem quebrar seu sistema no pior momento poss√≠vel.

---

## A Defini√ß√£o Formal de Barbara Liskov

Se voc√™ for como eu, precisar√° ler o que ela disse algumas vezes at√© entender o que ela quis
dizer. Mas vamos para a defini√ß√£o forma em ingl√™s e portugu√™s.

> "What is wanted here is something like the following substitution property: If for each object
> `o1` of type `S` there is an object `o2` of type `T` such that for all programs `P` defined in
> terms of `T`, the behavior of `P` is unchanged when `o1` is substituted for `o2`, then `S` is a
> subtype of `T`."

Tradu√ß√£o literal:

> "O que se quer aqui √© algo como a seguinte propriedade de substitui√ß√£o: se, para cada objeto
> `o1` do tipo `S`, existe um objeto `o2` do tipo `T`, de forma que, para todos os programas `P`
> definidos em termos de `T`, o comportamento de `P` permanece inalterado quando `o1` √©
> substitu√≠do por `o2`, ent√£o `S` √© um subtipo de `T`."

Entendeu? Ok, vamos decifrar isso juntos...

### O que ela quis dizer?

Tomei a liberdade de traduzir o que ela disse de uma forma menos formal. E eu n√£o fiz isso
enquanto escrevia este texto, foram anos quebrando a cabe√ßa at√© chegar em algo assim:

> `S` √© subtipo de `T` **somente** se **qualquer programa** escrito para funcionar com objetos do
> tipo `T` continuar se comportando **exatamente da mesma forma** quando receber um objeto do tipo
> `S`, sem "perceber" a troca.

Ou seja, **n√£o basta a tipagem bater com o Type Checker, o comportamento do subtipo tamb√©m precisa
ser compat√≠vel** com o comportamento do supertipo.

Voc√™ pode ter um c√≥digo perfeito para o type checker e mesmo assim quebrar o LSP se violar o
contrato do tipo base.

Se isso acontecer, com certeza ter√° bugs no seu programa no futuro.

---

## Como verificar se o LSP est√° sendo respeitado

O checklist cl√°ssico √© baseado em tr√™s pontos-chave: **pr√©-condi√ß√µes**, **p√≥s-condi√ß√µes** e
**invariantes**. Antes de analisarmos cada um, vale lembrar que **a compatibilidade come√ßa na
assinatura dos m√©todos**, ou seja, par√¢metros, retorno e exce√ß√µes fazem parte do contrato que o
subtipo precisa manter.

### Compatibilidade de assinaturas

- **Par√¢metros:** No subtipo, devem ser **iguais ou mais gen√©ricos** (**contravariantes**).
- **Retorno:** No subtipo, devem ser **iguais ou mais espec√≠ficos** (**covariantes**).
- **Exce√ß√µes:** O subtipo n√£o deve lan√ßar exce√ß√µes que n√£o sejam subtipos das lan√ßadas pela
  superclasse.

Em Python, o `Callable` j√° √© contravariante nos argumentos e covariante nos retornos. Para saber
qual exce√ß√£o √© subtipo de outra, veja a
[hierarquia de exceptions](https://docs.python.org/3/library/exceptions.html#exception-hierarchy).

Falamos sobre a vari√¢ncia no v√≠deo
[Gen√©ricos ABC, Covari√¢ncia, Contravari√¢ncia e Invari√¢ncia no Python - Aula 5](https://youtu.be/26BdcuNAlys).

---

### Pr√©-condi√ß√µes (inputs / par√¢metros)

Pr√©-condi√ß√µes est√£o relacionadas aos par√¢metros de entrada (ou inputs).

**Regra:** O subtipo **n√£o pode** ser mais restritivo que o tipo base.

**Exemplos:**

- Se a abstra√ß√£o aceita um container iter√°vel com **qualquer tipo de elemento**, o subtipo n√£o
  pode exigir uma `list[str]`.
- Se a abstra√ß√£o espera uma **URL** (HTTP ou HTTPS), o subtipo n√£o pode aceitar apenas **caminhos
  de arquivo local**.
- Se a abstra√ß√£o aceita **qualquer `int`**, o subtipo n√£o pode restringir para **apenas inteiros
  positivos**.
- Se a abstra√ß√£o aceita `str` **vazia ou n√£o vazia**, o subtipo n√£o pode proibir string vazia.
- Se a abstra√ß√£o aceita `None` como valor opcional, o subtipo n√£o pode rejeitar `None`.
- Se a abstra√ß√£o aceita **qualquer objeto** no `in` (`__contains__`), o subtipo n√£o pode lan√ßar
  `TypeError` para tipos diferentes.
- Se a abstra√ß√£o aceita `float` **com ou sem casas decimais**, o subtipo n√£o pode aceitar apenas
  n√∫meros inteiros representados como float (ex.: `1.0`, `2.0`).
- Se a abstra√ß√£o aceita **qualquer formato de data v√°lido**, o subtipo n√£o pode aceitar apenas
  `datetime.date` e rejeitar `datetime.datetime`.
- Se a abstra√ß√£o aceita par√¢metros **por posi√ß√£o ou por nome**, o subtipo n√£o pode exigir que
  todos sejam nomeados (ou todos posicionais).
- Se a abstra√ß√£o aceita qualquer arquivo aberto (modo leitura ou escrita), o subtipo n√£o pode
  exigir exclusivamente arquivos abertos em modo leitura.

---

### Exemplo concreto para pr√©-condi√ß√µes (inputs / par√¢metros)

Vejamos um exemplo onde o subtipo viola uma pr√©-condi√ß√£o do LSP:

```python
class Tags:
    def __init__(self, tags: set[str]) -> None:
        self._tags = tags

    # Contrato amplo: aceita qualquer objeto
    def __contains__(self, item: object) -> bool:
        return item in self._tags  # Para tipo "errado", retorna False


class StrictTags(Tags):
    # üö´ Pr√©-condi√ß√£o mais restritiva: agora s√≥ aceita str
    def __contains__(self, item: object) -> bool:
        if not isinstance(item, str):
            raise TypeError("item must be str")
        return item in self._tags


# Cliente escrito para o tipo base:
def has_tag(t: Tags, q: object) -> bool:
    return q in t


t1 = Tags({"python", "types"})
t2 = StrictTags({"python", "types"})

print(has_tag(t1, 123))  # False (ok no contrato do base)
print(has_tag(t2, 123))  # üí• TypeError, subtipo ficou mais restritivo
```

No c√≥digo acima, `Tags` aceita que qualquer `object` seja utilizado com `__contains__` (`in` e
`not in`). Mas `StrictTags` imp√µe que apenas `str` pode ser utilizado. O type checker n√£o reclama,
mas o comportamento mudou, quebrando a pr√©-condi√ß√£o da classe base.

Pode parecer sutil, pode funcionar agora, mas em algum momento isso vai quebrar.

---

### P√≥s-condi√ß√µes (retorno / output)

**Regra:** O subtipo **n√£o pode** entregar menos do que o tipo base, ou seja, n√£o pode enfraquecer
as condi√ß√µes do tipo base.

**Exemplos:**

- Se o pai promete **retornar sempre um n√∫mero positivo**, o filho n√£o pode retornar negativos.
- Se o pai promete retornar um **objeto n√£o nulo** (`None` nunca √© retorno v√°lido), o filho n√£o
  pode retornar `None`.
- Se o pai promete retornar uma **cole√ß√£o ordenada**, o filho n√£o pode retornar elementos fora de
  ordem.
- Se o pai promete retornar **todos os registros** encontrados, o filho n√£o pode retornar apenas
  parte deles sem avisar.
- Se o pai promete retornar um **tipo espec√≠fico** (`list`), o filho n√£o pode retornar outro tipo
  compat√≠vel mas diferente (`tuple`, `set`), mesmo que tenha os mesmos dados.
- Se o pai promete retornar **um valor convertido para min√∫sculas**, o filho n√£o pode retornar o
  valor com caixa mista.
- Se o pai promete retornar um **JSON v√°lido**, o filho n√£o pode retornar uma string que n√£o seja
  JSON parse√°vel.
- Se o pai promete retornar um **arquivo leg√≠vel at√© o fim**, o filho n√£o pode retornar um arquivo
  truncado.
- Se o pai promete retornar um **caminho absoluto**, o filho n√£o pode retornar um caminho
  relativo.
- Se o pai promete retornar um **hash √∫nico**, o filho n√£o pode retornar um valor fixo ou
  repetido.

> **Observa√ß√£o:** Voc√™ pode **prometer mais** que o pai, mas nunca menos.

---

### Exemplo concreto para p√≥s-condi√ß√µes (outputs / retornos)

Um exemplo de algo que s√≥ retorna positivos no Python √© o `__len__`. Este m√©todo √© chamado ao usar
`len()` para saber quantos itens existem no container. Ou o container est√° vazio (0 itens) ou tem
elementos. Ele nunca ter√° uma quantidade negativa de itens.

```python
# Tipagem perfeita, mas p√≥s-condi√ß√£o violada
class SizedProtocol:
    def __init__(self, data: list[int]) -> None:
        self._data = data

    def __len__(self) -> int:
        return len(self._data)  # Sempre >= 0 (contrato impl√≠cito do Python)

class BadSized(SizedProtocol):
    def __len__(self) -> int:
        return len(self._data) - 1  # üö´ Pode gerar valor negativo (sutil)


bad_sized = BadSized([])  # Vazio, ent√£o seria zero, mas ser√° -1
size = len(bad_sized)     # ValueError: __len__() should return >= 0
```

Esse exemplo j√° quebrou antes de nascer, bastou passar um objeto vazio e pedir quantos itens ele
tem.

---

### Invariantes (verdades que sempre se mant√™m)

**Regra:** O subtipo deve manter todos os invariantes do tipo base.

**Exemplos:**

- Se a classe base garante que um **ID √© imut√°vel ap√≥s cria√ß√£o**, o subtipo n√£o pode permitir
  alterar o ID.
- Se a classe base garante que o **saldo inicial de conta banc√°ria ‚â• 0**, o subtipo n√£o pode criar
  contas com saldo negativo.
- Se a classe base garante que uma **lista est√° sempre ordenada**, o subtipo n√£o pode inserir
  elementos fora de ordem.
- Se a classe base garante que a **largura e altura s√£o independentes**, o subtipo n√£o pode for√ßar
  que sejam sempre iguais (cl√°ssico `Rectangle` vs `Square`).
- Se a classe base garante que um **arquivo tempor√°rio √© apagado ap√≥s uso**, o subtipo n√£o pode
  manter o arquivo no disco.
- Se a classe base garante que a **conex√£o com banco de dados est√° aberta** enquanto o objeto
  existir, o subtipo n√£o pode fechar a conex√£o no meio da execu√ß√£o.
- Se a classe base garante que **valores duplicados n√£o existem** numa cole√ß√£o, o subtipo n√£o pode
  permitir duplicatas.
- Se a classe base garante que **datas est√£o sempre no futuro** (ex.: agendamento), o subtipo n√£o
  pode permitir datas no passado.
- Se a classe base garante que um **token expira em at√© 1 hora**, o subtipo n√£o pode emitir tokens
  com expira√ß√£o indefinida.
- Se a classe base garante que a **moeda de uma transa√ß√£o √© fixa** ap√≥s cria√ß√£o, o subtipo n√£o
  pode permitir mudar a moeda depois.

---

### Exemplo concreto para invariantes (verdades que devem se manter)

Um dos exemplos mais conhecidos de quebra de invariante √© quando se tenta usar o `Quadrado` como
subtipo de `Ret√¢ngulo`. A ideia parece natural: _um quadrado √© um ret√¢ngulo com a mesma altura e
largura_.

O problema √© que, nessa frase, j√° quebramos a invariante dos dois:

- **Ret√¢ngulo:** largura e altura s√£o **independentes**.
- **Quadrado:** largura e altura s√£o **sempre iguais**.

Ou seja, `Quadrado` e `Ret√¢ngulo` s√£o objetos distintos que, por acaso, compartilham uma
propriedade em comum: a **√°rea**. Mas, se for por isso, `C√≠rculo` tamb√©m tem √°rea e nem por isso √©
um ret√¢ngulo.

Para ilustrar um caso diferente do cl√°ssico ret√¢ngulo/quadrado, veja o c√≥digo abaixo:

```python
class DatabaseConfig:
    def __init__(self, dsn: str) -> None:
        self._dsn = dsn

    @property
    def dsn(self) -> str: # uma invari√¢ncia
        return self._dsn


class MySqlDatabaseConfig(DatabaseConfig):
    def __init__(self, host: str, user: str, password: str, db: str) -> None:
        # N√£o tem DSN, mas for√ßa heran√ßa para "reaproveitar" m√©todos
        self.host = host
        self.user = user
        self.password = password
        self.db = db

        # Apenas inicializa a base com valor vazio (quebrando a invariante)
        super().__init__("")


def connect(cfg: DatabaseConfig) -> None:
    # Cliente depende da invariante DatabaseConfig.dsn
    print("Connecting to:", cfg.dsn)


cfg_bad = MySqlDatabaseConfig(host="", user="root", password="", db="app")
connect(cfg_bad)  # ‚ùå imprime DSN vazio; quebra a invariante
```

No exemplo acima, `DatabaseConfig` foi projetada para trabalhar com `dsn` como parte obrigat√≥ria.
O subtipo herda a classe mas ignora essa regra, inicializando com valor vazio. Isso quebra o
contrato impl√≠cito de que `dsn` sempre est√° configurado.

Uma forma de resolver seria:

- Extrair m√©todos compartilhados para outra classe/m√≥dulo, evitando heran√ßa for√ßada.
- Padronizar todas as subclasses para realmente usarem `dsn` no mesmo formato.

---

## Por que isso importa?

O LSP √© f√°cil de quebrar sem perceber. N√£o √© preciso "heran√ßa do mal" nem mudar tipagem, um
simples detalhe de l√≥gica j√° quebra o contrato. Muitos desses bugs s√£o sutis e podem viver
despercebidos por anos... at√© que um dia üí•üí•üí•.

No fim das contas, respeitar o LSP √© menos sobre decorar uma defini√ß√£o formal e mais sobre
entender o **contrato invis√≠vel** que existe entre a classe base e seus subtipos. Muitas viola√ß√µes
n√£o aparecem nos testes de tipagem, nem nos seus testes automatizados, mas cobram seu pre√ßo em
produ√ß√£o, quando o sistema come√ßa a se comportar de forma inesperada. Ent√£o, da pr√≥xima vez que
criar uma hierarquia de classes, lembre-se: herdar √© f√°cil, mas herdar corretamente √© outra
hist√≥ria completamente diferente.

---
