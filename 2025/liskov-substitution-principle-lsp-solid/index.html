<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>
      Liskov Substitution Principle ou Princ√≠pio da Substitui√ß√£o de Liskov -
      Ot√°vio Miranda
    </title>
    <meta
      name="description"
      content="Liskov Substitution Principle explicado: valide pr√©‚Äëcondi√ß√µes, p√≥s‚Äëcondi√ß√µes e invariantes com casos reais e c√≥digo Python."
    />

    <link rel="stylesheet" href="../../css/styles_2026.css" />

    <link rel="icon" type="image/webp" href="../../imgs/favicon-1.webp" />
  </head>
  <body>
    <input
      aria-label="Tema Claro ou Escuro (Tempor√°rio)"
      title="Tema Claro ou Escuro (Tempor√°rio)"
      id="theme-mode"
      type="checkbox"
    />

    <main class="main">
      <aside class="nav">
        <a class="copyright-link" href="/">Ot√°vio Miranda</a>
        <a
          href="https://beacons.ai/otaviomiranda"
          rel="nofollow noopener noreferrer"
          >Contatos</a
        >
      </aside>

      <article class="article">
        <h1 id="user-content-liskov-substitution-principle-lsp-into">
          O Princ√≠pio da Substitui√ß√£o de Liskov (LSP)
        </h1>

        <blockquote>
          <p>
            Publicado em 12 de agosto de 2025 | Por
            <a
              target="_blank"
              rel="noopener noreferrer"
              href="https://www.otaviomiranda.com.br/"
              >Luiz Ot√°vio Miranda</a
            >
          </p>
        </blockquote>
        <p>
          Quem j√° trabalhou com heran√ßa na programa√ß√£o orientada a objetos,
          muito provavelmente tamb√©m j√° ouviu falar sobre o Princ√≠pio da
          Substitui√ß√£o de Liskov, ou at√© j√° sofreu na pr√°tica quando ele foi
          quebrado no seu programa.
        </p>
        <p>
          Introduzido
          <a
            target="_blank"
            rel="noopener noreferrer"
            href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"
            >por Barbara Liskov em 1987</a
          >, o LSP √© um dos cinco princ√≠pios do famoso SOLID e define uma regra
          simples, mas muito poderosa: um subtipo deve poder substituir seu tipo
          base sem que o comportamento esperado do sistema mude.
        </p>
        <p>
          Parece simple e extremamente √≥bvio, mas n√£o √©. O que muita gente
          esquece √© que n√£o basta a tipagem funcionar, o comportamento (a sua
          l√≥gica) tamb√©m precisa ser compat√≠vel. √â aqui que entram conceitos
          como pr√©-condi√ß√µes, p√≥s-condi√ß√µes e invariantes: tr√™s pilares que
          ajudam a identificar se um subtipo realmente respeita o contrato
          definido pela superclasse.
        </p>
        <p>
          Neste artigo, vamos entender a defini√ß√£o formal do LSP, traduzi-la
          para um contexto mais pr√°tico e analisar exemplos, desde os cl√°ssicos,
          at√© situa√ß√µes sutis que passam despercebidas por type checkers, mas
          que podem quebrar seu sistema no pior momento poss√≠vel.
        </p>
        <hr />
        <h2>A Defini√ß√£o Formal de Barbara Liskov</h2>
        <p>
          Se voc√™ for como eu, precisar√° ler o que ela disse algumas vezes at√©
          entender o que ela quis dizer. Mas vamos para a defini√ß√£o forma em
          ingl√™s e portugu√™s.
        </p>
        <blockquote>
          <p>
            "What is wanted here is something like the following substitution
            property: If for each object o1 of type S there is an object o2 of
            type T such that for all programs P defined in terms of T, the
            behavior of P is unchanged when o1 is substituted for o2, then S is
            a subtype of T."
          </p>
        </blockquote>
        <p>Tradu√ß√£o literal:</p>
        <blockquote>
          <p>
            "O que se quer aqui √© algo como a seguinte propriedade de
            substitui√ß√£o: se, para cada objeto o1 do tipo S, existe um objeto o2
            do tipo T, de forma que, para todos os programas P definidos em
            termos de T, o comportamento de P permanece inalterado quando o1 √©
            substitu√≠do por o2, ent√£o S √© um subtipo de T."
          </p>
        </blockquote>
        <p>Entendeu? Ok, vamos decifrar isso juntos...</p>
        <h3>O que ela quis dizer?</h3>
        <p>
          Tomei a liberdade de traduzir o que ela disse de uma forma menos
          formal. E eu n√£o fiz isso enquanto escrevia este texto, foram anos
          quebrando a cabe√ßa at√© chegar em algo assim:
        </p>
        <blockquote>
          <p>
            S √© subtipo de T somente se qualquer programa escrito para funcionar
            com objetos do tipo T continuar se comportando exatamente da mesma
            forma quando receber um objeto do tipo S, sem "perceber" a troca.
          </p>
        </blockquote>
        <p>
          Ou seja, n√£o basta a tipagem bater com o Type Checker, o comportamento
          do subtipo tamb√©m precisa ser compat√≠vel com o comportamento do
          supertipo.
        </p>
        <p>
          Voc√™ pode ter um c√≥digo perfeito para o type checker e mesmo assim
          quebrar o LSP se violar o contrato do tipo base.
        </p>
        <p>
          Se isso acontecer, com certeza ter√° bugs no seu programa no futuro.
        </p>
        <hr />
        <h2>Como verificar se o LSP est√° sendo respeitado</h2>
        <p>
          O checklist cl√°ssico √© baseado em tr√™s pontos-chave: pr√©-condi√ß√µes,
          p√≥s-condi√ß√µes e invariantes. Antes de analisarmos cada um, vale
          lembrar que a compatibilidade come√ßa na assinatura dos m√©todos, ou
          seja, par√¢metros, retorno e exce√ß√µes fazem parte do contrato que o
          subtipo precisa manter.
        </p>
        <h3>Compatibilidade de assinaturas</h3>
        <ul>
          <li>
            Par√¢metros: No subtipo, devem ser iguais ou mais gen√©ricos
            (contravariantes).
          </li>
          <li>
            Retorno: No subtipo, devem ser iguais ou mais espec√≠ficos
            (covariantes).
          </li>
          <li>
            Exce√ß√µes: O subtipo n√£o deve lan√ßar exce√ß√µes que n√£o sejam subtipos
            das lan√ßadas pela superclasse.
          </li>
        </ul>
        <p>
          Em Python, o Callable j√° √© contravariante nos argumentos e covariante
          nos retornos. Para saber qual exce√ß√£o √© subtipo de outra, veja a
          <a
            target="_blank"
            rel="noopener noreferrer"
            href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy"
            >hierarquia de exceptions</a
          >.
        </p>
        <p>
          Falamos sobre a vari√¢ncia no v√≠deo
          <a
            target="_blank"
            rel="noopener noreferrer"
            href="https://youtu.be/26BdcuNAlys"
            >Gen√©ricos ABC, Covari√¢ncia, Contravari√¢ncia e Invari√¢ncia no Python
            - Aula 5</a
          >.
        </p>
        <hr />
        <h3>Pr√©-condi√ß√µes (inputs / par√¢metros)</h3>
        <p>
          Pr√©-condi√ß√µes est√£o relacionadas aos par√¢metros de entrada (ou
          inputs).
        </p>
        <p>Regra: O subtipo n√£o pode ser mais restritivo que o tipo base.</p>
        <p>Exemplos:</p>
        <ul>
          <li>
            Se a abstra√ß√£o aceita um container iter√°vel com qualquer tipo de
            elemento, o subtipo n√£o pode exigir uma list[str].
          </li>
          <li>
            Se a abstra√ß√£o espera uma URL (HTTP ou HTTPS), o subtipo n√£o pode
            aceitar apenas caminhos de arquivo local.
          </li>
          <li>
            Se a abstra√ß√£o aceita qualquer int, o subtipo n√£o pode restringir
            para apenas inteiros positivos.
          </li>
          <li>
            Se a abstra√ß√£o aceita str vazia ou n√£o vazia, o subtipo n√£o pode
            proibir string vazia.
          </li>
          <li>
            Se a abstra√ß√£o aceita None como valor opcional, o subtipo n√£o pode
            rejeitar None.
          </li>
          <li>
            Se a abstra√ß√£o aceita qualquer objeto no in (__contains__), o
            subtipo n√£o pode lan√ßar TypeError para tipos diferentes.
          </li>
          <li>
            Se a abstra√ß√£o aceita float com ou sem casas decimais, o subtipo n√£o
            pode aceitar apenas n√∫meros inteiros representados como float (ex.:
            1.0, 2.0).
          </li>
          <li>
            Se a abstra√ß√£o aceita qualquer formato de data v√°lido, o subtipo n√£o
            pode aceitar apenas datetime.date e rejeitar datetime.datetime.
          </li>
          <li>
            Se a abstra√ß√£o aceita par√¢metros por posi√ß√£o ou por nome, o subtipo
            n√£o pode exigir que todos sejam nomeados (ou todos posicionais).
          </li>
          <li>
            Se a abstra√ß√£o aceita qualquer arquivo aberto (modo leitura ou
            escrita), o subtipo n√£o pode exigir exclusivamente arquivos abertos
            em modo leitura.
          </li>
        </ul>
        <hr />
        <h3>Exemplo concreto para pr√©-condi√ß√µes (inputs / par√¢metros)</h3>
        <p>Vejamos um exemplo onde o subtipo viola uma pr√©-condi√ß√£o do LSP:</p>
        <pre>
class Tags:
    def __init__(self, tags: set[str]) -&gt; None:
        self._tags = tags

    # Contrato amplo: aceita qualquer objeto
    def __contains__(self, item: object) -&gt; bool:
        return item in self._tags  # Para tipo "errado", retorna False


class StrictTags(Tags):
    # üö´ Pr√©-condi√ß√£o mais restritiva: agora s√≥ aceita str
    def __contains__(self, item: object) -&gt; bool:
        if not isinstance(item, str):
            raise TypeError("item must be str")
        return item in self._tags


# Cliente escrito para o tipo base:
def has_tag(t: Tags, q: object) -&gt; bool:
    return q in t


t1 = Tags({"python", "types"})
t2 = StrictTags({"python", "types"})

print(has_tag(t1, 123))  # False (ok no contrato do base)
print(has_tag(t2, 123))  # üí• TypeError, subtipo ficou mais restritivo</pre
        >
        <p>
          No c√≥digo acima, Tags aceita que qualquer object seja utilizado com
          __contains__ (in e not in). Mas StrictTags imp√µe que apenas str pode
          ser utilizado. O type checker n√£o reclama, mas o comportamento mudou,
          quebrando a pr√©-condi√ß√£o da classe base.
        </p>
        <p>
          Pode parecer sutil, pode funcionar agora, mas em algum momento isso
          vai quebrar.
        </p>
        <hr />
        <h3>P√≥s-condi√ß√µes (retorno / output)</h3>
        <p>
          Regra: O subtipo n√£o pode entregar menos do que o tipo base, ou seja,
          n√£o pode enfraquecer as condi√ß√µes do tipo base.
        </p>
        <p>Exemplos:</p>
        <ul>
          <li>
            Se o pai promete retornar sempre um n√∫mero positivo, o filho n√£o
            pode retornar negativos.
          </li>
          <li>
            Se o pai promete retornar um objeto n√£o nulo (None nunca √© retorno
            v√°lido), o filho n√£o pode retornar None.
          </li>
          <li>
            Se o pai promete retornar uma cole√ß√£o ordenada, o filho n√£o pode
            retornar elementos fora de ordem.
          </li>
          <li>
            Se o pai promete retornar todos os registros encontrados, o filho
            n√£o pode retornar apenas parte deles sem avisar.
          </li>
          <li>
            Se o pai promete retornar um tipo espec√≠fico (list), o filho n√£o
            pode retornar outro tipo compat√≠vel mas diferente (tuple, set),
            mesmo que tenha os mesmos dados.
          </li>
          <li>
            Se o pai promete retornar um valor convertido para min√∫sculas, o
            filho n√£o pode retornar o valor com caixa mista.
          </li>
          <li>
            Se o pai promete retornar um JSON v√°lido, o filho n√£o pode retornar
            uma string que n√£o seja JSON parse√°vel.
          </li>
          <li>
            Se o pai promete retornar um arquivo leg√≠vel at√© o fim, o filho n√£o
            pode retornar um arquivo truncado.
          </li>
          <li>
            Se o pai promete retornar um caminho absoluto, o filho n√£o pode
            retornar um caminho relativo.
          </li>
          <li>
            Se o pai promete retornar um hash √∫nico, o filho n√£o pode retornar
            um valor fixo ou repetido.
          </li>
        </ul>
        <blockquote>
          <p>Observa√ß√£o: Voc√™ pode prometer mais que o pai, mas nunca menos.</p>
        </blockquote>
        <hr />
        <h3>Exemplo concreto para p√≥s-condi√ß√µes (outputs / retornos)</h3>
        <p>
          Um exemplo de algo que s√≥ retorna positivos no Python √© o __len__.
          Este m√©todo √© chamado ao usar len() para saber quantos itens existem
          no container. Ou o container est√° vazio (0 itens) ou tem elementos.
          Ele nunca ter√° uma quantidade negativa de itens.
        </p>
        <pre>
# Tipagem perfeita, mas p√≥s-condi√ß√£o violada
class SizedProtocol:
    def __init__(self, data: list[int]) -&gt; None:
        self._data = data

    def __len__(self) -&gt; int:
        return len(self._data)  # Sempre &gt;= 0 (contrato impl√≠cito do Python)

class BadSized(SizedProtocol):
    def __len__(self) -&gt; int:
        return len(self._data) - 1  # üö´ Pode gerar valor negativo (sutil)


bad_sized = BadSized([])  # Vazio, ent√£o seria zero, mas ser√° -1
size = len(bad_sized)     # ValueError: __len__() should return &gt;= 0</pre
        >
        <p>
          Esse exemplo j√° quebrou antes de nascer, bastou passar um objeto vazio
          e pedir quantos itens ele tem.
        </p>
        <hr />
        <h3>Invariantes (verdades que sempre se mant√™m)</h3>
        <p>Regra: O subtipo deve manter todos os invariantes do tipo base.</p>
        <p>Exemplos:</p>
        <ul>
          <li>
            Se a classe base garante que um ID √© imut√°vel ap√≥s cria√ß√£o, o
            subtipo n√£o pode permitir alterar o ID.
          </li>
          <li>
            Se a classe base garante que o saldo inicial de conta banc√°ria ‚â• 0,
            o subtipo n√£o pode criar contas com saldo negativo.
          </li>
          <li>
            Se a classe base garante que uma lista est√° sempre ordenada, o
            subtipo n√£o pode inserir elementos fora de ordem.
          </li>
          <li>
            Se a classe base garante que a largura e altura s√£o independentes, o
            subtipo n√£o pode for√ßar que sejam sempre iguais (cl√°ssico Rectangle
            vs Square).
          </li>
          <li>
            Se a classe base garante que um arquivo tempor√°rio √© apagado ap√≥s
            uso, o subtipo n√£o pode manter o arquivo no disco.
          </li>
          <li>
            Se a classe base garante que a conex√£o com banco de dados est√°
            aberta enquanto o objeto existir, o subtipo n√£o pode fechar a
            conex√£o no meio da execu√ß√£o.
          </li>
          <li>
            Se a classe base garante que valores duplicados n√£o existem numa
            cole√ß√£o, o subtipo n√£o pode permitir duplicatas.
          </li>
          <li>
            Se a classe base garante que datas est√£o sempre no futuro (ex.:
            agendamento), o subtipo n√£o pode permitir datas no passado.
          </li>
          <li>
            Se a classe base garante que um token expira em at√© 1 hora, o
            subtipo n√£o pode emitir tokens com expira√ß√£o indefinida.
          </li>
          <li>
            Se a classe base garante que a moeda de uma transa√ß√£o √© fixa ap√≥s
            cria√ß√£o, o subtipo n√£o pode permitir mudar a moeda depois.
          </li>
        </ul>
        <hr />
        <h3>
          Exemplo concreto para invariantes (verdades que devem se manter)
        </h3>
        <p>
          Um dos exemplos mais conhecidos de quebra de invariante √© quando se
          tenta usar o Quadrado como subtipo de Ret√¢ngulo. A ideia parece
          natural: um quadrado √© um ret√¢ngulo com a mesma altura e largura.
        </p>
        <p>
          O problema √© que, nessa frase, j√° quebramos a invariante dos dois:
        </p>
        <ul>
          <li>Ret√¢ngulo: largura e altura s√£o independentes.</li>
          <li>Quadrado: largura e altura s√£o sempre iguais.</li>
        </ul>
        <p>
          Ou seja, Quadrado e Ret√¢ngulo s√£o objetos distintos que, por acaso,
          compartilham uma propriedade em comum: a √°rea. Mas, se for por isso,
          C√≠rculo tamb√©m tem √°rea e nem por isso √© um ret√¢ngulo.
        </p>
        <p>
          Para ilustrar um caso diferente do cl√°ssico ret√¢ngulo/quadrado, veja o
          c√≥digo abaixo:
        </p>
        <pre>
class DatabaseConfig:
    def __init__(self, dsn: str) -&gt; None:
        self._dsn = dsn

    @property
    def dsn(self) -&gt; str: # uma invari√¢ncia
        return self._dsn


class MySqlDatabaseConfig(DatabaseConfig):
    def __init__(self, host: str, user: str, password: str, db: str) -&gt; None:
        # N√£o tem DSN, mas for√ßa heran√ßa para "reaproveitar" m√©todos
        self.host = host
        self.user = user
        self.password = password
        self.db = db

        # Apenas inicializa a base com valor vazio (quebrando a invariante)
        super().__init__("")


def connect(cfg: DatabaseConfig) -&gt; None:
    # Cliente depende da invariante DatabaseConfig.dsn
    print("Connecting to:", cfg.dsn)


cfg_bad = MySqlDatabaseConfig(host="", user="root", password="", db="app")
connect(cfg_bad)  # ‚ùå imprime DSN vazio; quebra a invariante</pre
        >
        <p>
          No exemplo acima, DatabaseConfig foi projetada para trabalhar com dsn
          como parte obrigat√≥ria. O subtipo herda a classe mas ignora essa
          regra, inicializando com valor vazio. Isso quebra o contrato impl√≠cito
          de que dsn sempre est√° configurado.
        </p>
        <p>Uma forma de resolver seria:</p>
        <ul>
          <li>
            Extrair m√©todos compartilhados para outra classe/m√≥dulo, evitando
            heran√ßa for√ßada.
          </li>
          <li>
            Padronizar todas as subclasses para realmente usarem dsn no mesmo
            formato.
          </li>
        </ul>
        <hr />
        <h2>Por que isso importa?</h2>
        <p>
          O LSP √© f√°cil de quebrar sem perceber. N√£o √© preciso "heran√ßa do mal"
          nem mudar tipagem, um simples detalhe de l√≥gica j√° quebra o contrato.
          Muitos desses bugs s√£o sutis e podem viver despercebidos por anos...
          at√© que um dia üí•üí•üí•.
        </p>
        <p>
          No fim das contas, respeitar o LSP √© menos sobre decorar uma defini√ß√£o
          formal e mais sobre entender o contrato invis√≠vel que existe entre a
          classe base e seus subtipos. Muitas viola√ß√µes n√£o aparecem nos testes
          de tipagem, nem nos seus testes automatizados, mas cobram seu pre√ßo em
          produ√ß√£o, quando o sistema come√ßa a se comportar de forma inesperada.
          Ent√£o, da pr√≥xima vez que criar uma hierarquia de classes, lembre-se:
          herdar √© f√°cil, mas herdar corretamente √© outra hist√≥ria completamente
          diferente.
        </p>
      </article>

      <footer class="nav">
        <a class="copyright-link" href="/">Ot√°vio Miranda</a>
        <a
          target="_blank"
          href="https://beacons.ai/otaviomiranda"
          rel="nofollow noopener noreferrer"
          >Contatos</a
        >
      </footer>
    </main>

    <script defer src="../../js/scripts_2026.js"></script>
  </body>
</html>
