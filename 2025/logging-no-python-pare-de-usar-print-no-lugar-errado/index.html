<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>logging no Python: Pare de usar print no lugar errado - Ot√°vio Miranda</title>
    <meta name="description" content="Nesse artigo falamos do m√≥dulo logging no Python do b√°sico ao avan√ßado. Pare de usar o print no local errado e comece a ter logs na sua aplica√ß√£o Python." />

    <link rel="stylesheet" href="../../css/markdown.css" />

    <link rel="icon" type="image/webp" href="../../imgs/favicon-1.webp" />

    <!-- Estilo escuro para markdown (GitHub dark) -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-dark.min.css"
    />

    <!-- Tema dark do highlight.js -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css"
    />
  </head>
  <body>
    <nav class="breadcrumb-nav">
      <a href="/">&larr; ir para in√≠cio</a>

      <form
        id="main-search"
        action="https://www.google.com/search"
        method="get"
        target="_blank"
      >
        <input type="search" name="q" placeholder="Buscar no site via Google" />
        <button type="submit">Buscar</button>
      </form>
    </nav>

    <article class="markdown-body" id="content"></article>

    <!-- prettier-ignore -->
    <script type="text/markdown" id="markdown-source">










<h1 id="logging-no-python-pare-de-usar-print-no-lugar-errado">
  <a href="#logging-no-python-pare-de-usar-print-no-lugar-errado">
    `logging` no Python: Pare de usar `print` no lugar errado
  </a>
</h1>

> **Publicado em** 05 de julho de 2025 | **Por**
> [Luiz Ot√°vio Miranda](https://www.otaviomiranda.com.br/)

O `logging` √© o m√≥dulo oficial do Python para lidar com logs de forma
estruturada, profissional e extens√≠vel. Al√©m disso, ele serve como uma
alternativa muito mais poderosa ao velho e conhecido `print()` para debug r√°pido
durante o desenvolvimento.

Enquanto o `print()` √© √≥timo pra exibir algo na tela, o `logging` te d√° controle
total sobre o evento que vai ser registrado, **como** vai ser formatado e **pra
onde** essa informa√ß√£o vai (terminal, arquivo, socket, banco, etc). S√£o fun√ß√µes
diferentes entre `print` e `logging`, mas esse comparativo sempre aparece quando
falamos de `logging`.

Ele tamb√©m trabalha com n√≠veis de severidade (`DEBUG`, `INFO`, `WARNING`,
`ERROR`, `CRITICAL`), suporta m√∫ltiplos formatos, m√∫ltiplos destinos (handlers),
hierarquia de loggers e configura√ß√£o via c√≥digo ou arquivos externos.

Em outras palavras: ele foi feito pra `log` em aplica√ß√µes reais. S√£o registros
de eventos categorizados para aplica√ß√µes de gente grande, que sabe o que est√°
fazendo e sabe que vai precisar debugar e refatorar o c√≥digo em algum momento.

O melhor √© que j√° vem com o Python. Sem depend√™ncia. Sem gambiarra.

---

<h2 id="links-uteis-para-este-artigo">
  <a href="#links-uteis-para-este-artigo">
      Links √∫teis para este artigo
  </a>
</h2>

Se voc√™ caiu nesse artigo de paraquedas, ele √© apenas parte de um conte√∫do BEM
MAIOR. Temos todo esse texto em v√≠deo no Youtube e tamb√©m um reposit√≥rio com
todo o c√≥digo, segue:

- [Logging no Python - Curso completo](https://www.youtube.com/playlist?list=PLbIBj8vQhvm28qR-yvWP3JELGelWxsxaI)
- [Reposit√≥rio do curso](https://github.com/luizomf/logging_course_yt)

Ent√£o vamos continuar...

---

<h2 id="como-o-logging-funciona-por-dentro">
  <a href="#como-o-logging-funciona-por-dentro">
    Como o `logging` funciona por dentro
  </a>
</h2>

O sistema de logging do Python √© organizado como uma estrutura hier√°rquica (em
forma de √°rvore), onde cada _logger_ √© um objeto √∫nico identificado por um nome
textual (por exemplo: `meuapp`, `meuapp.api`, etc). Essa hierarquia √© definida
simplesmente pelo nome, usando pontos (`.`) para indicar n√≠veis diferentes.

Exemplo de loggers:

- `app`
- `app.database`
- `app.http`
- `app.http.requests`

Visualmente, a estrutura ficaria assim:

```text
root
‚îî‚îÄ‚îÄ app
    ‚îú‚îÄ‚îÄ database
    ‚îî‚îÄ‚îÄ http
        ‚îî‚îÄ‚îÄ requests
```

Essa hierarquia permite algo muito poderoso: a **propaga√ß√£o** dos logs. Por
padr√£o, quando um logger emite um log, essa mensagem sobe na hierarquia at√©
chegar ao logger pai e, eventualmente, ao logger raiz (`root`).

Na pr√°tica, isso significa que voc√™ pode configurar todos os handlers (por
exemplo: imprimir no terminal, gravar em arquivos, enviar logs para servi√ßos
externos) diretamente no logger raiz. Assim, todos os loggers filhos
automaticamente reutilizam esses handlers, sem precisar configur√°-los
individualmente toda vez.

S√≥ tem um detalhe importante aqui: algumas bibliotecas tamb√©m usam loggers
internamente, seguindo essa mesma hierarquia de nomes. Por isso, os logs
emitidos por essas libs podem acabar sendo capturados pelos seus handlers
globais tamb√©m‚Äîdesde que o n√≠vel configurado permita isso, √© claro.

> **Nota:** Se seu app n√£o for grande e cheio de partes independentes, n√£o
> precisa complicar criando m√∫ltiplos loggers e uma hierarquia extensa. Na
> maioria dos casos, um √∫nico logger j√° resolve tudo.

Nos exemplos a seguir, vamos ver tudo isso funcionando claramente na pr√°tica.

---

<h2 id="conceitos-principais-loggers-handlers-formatters-e-filters">
  <a href="#conceitos-principais-loggers-handlers-formatters-e-filters">
    Conceitos principais: Loggers, Handlers, Formatters e Filters
  </a>
</h2>

O `logging` √© formado por 4 blocos principais:

- **Logger:** √© quem dispara a mensagem (ex: `logger.info("oi")`).
- **Handler:** define **pra onde** a mensagem vai (terminal, arquivo, e-mail
  etc).
- **Formatter:** define **como** a mensagem vai aparecer (formato da string).
- **Filter (opcional):** permite **filtrar** o que ser√° logado.

Esses blocos funcionam como pe√ßas de LEGO: voc√™ encaixa e combina como quiser.

Pode ter um logger que salva tudo em um arquivo `.json`, outro que s√≥ mostra
`ERROR` no terminal com cor, outro que manda `INFO` pro Telegram (por que n√£o?).

Tudo isso √© configur√°vel via c√≥digo ou por arquivos `.ini`, `.yaml`, `.json`,
como preferir.

---

<h2 id="niveis-de-severidade-level">
  <a href="#niveis-de-severidade-level">
    N√≠veis de severidade: `level`
  </a>
</h2>

O n√≠vel de severidade (`level`) aparece em dois momentos distintos:

1. Na configura√ß√£o do logger e/ou handler.
2. Na emiss√£o do log.

A primeira define o que ser√° aceito ou descartado. A segunda define qual a
severidade de um log espec√≠fico.

```python
# 1. Configura√ß√£o: esse logger aceita logs de WARNING pra cima
logger.setLevel(logging.WARNING)

# ...

# 2. Emiss√£o: esse log ser√° emitido com n√≠vel DEBUG
logger.debug("sou um debug")
```

---

<h3 id="como-o-level-funciona">
  <a href="#como-o-level-funciona">
    Como o `level` funciona
  </a>
</h3>

Tanto loggers quanto handlers possuem um `level`. Esse valor determina se uma
mensagem ser√° processada ou descartada, com base em sua severidade.

Os n√≠veis dispon√≠veis s√£o:

- `NOTSET` ou `0` ‚Äì sem configura√ß√£o expl√≠cita.
- `DEBUG` ou `10` ‚Äì detalhes t√©cnicos para depura√ß√£o (tipo `print()`).
- `INFO` ou `20` ‚Äì informa√ß√µes gerais da execu√ß√£o.
- `WARNING` ou `30` ‚Äì algo inesperado aconteceu, mas foi contornado.
- `ERROR` ou `40` ‚Äì erro durante a execu√ß√£o.
- `CRITICAL` ou `50` ‚Äì erro grave. A aplica√ß√£o pode parar ou j√° parou.

Voc√™ pode usar os nomes (`DEBUG`, `INFO`...) ou os n√∫meros diretamente.

> O valor num√©rico importa porque a regra √©: **um log s√≥ ser√° processado se o
> `level` desse log for maior ou igual ao `level` do logger e do handler.**

---

**Exemplo pr√°tico usando `level`**

```python
logger.setLevel(logging.ERROR)

logger.debug("DEBUG")     # ignorado
logger.warning("WARNING") # ignorado
logger.error("ERROR")     # processado
logger.critical("CRITICAL") # processado
```

---

<h3 id="emissao-de-um-log-em-um-level-especifico">
  <a href="#emissao-de-um-log-em-um-level-especifico">
    Emiss√£o de um log em um `level` espec√≠fico
  </a>
</h3>

Para emitir um log, usamos os m√©todos do logger que correspondem ao n√≠vel de
severidade desejado:

- `logger.debug(...)`
- `logger.info(...)`
- `logger.warning(...)`
- `logger.error(...)`
- `logger.critical(...)`

Exemplo:

```python
# Isso emite um log com n√≠vel WARNING (30)
logger.warning("mensagem do meu log")
```

Neste caso, estamos emitindo uma mensagem com n√≠vel 30 (`WARNING`). Ela ser√°
avaliada pelo logger e por cada handler configurado, e s√≥ ser√° processada se
passar pelos filtros de `level`.

---

<h2 id="basicconfig-iniciando-com-logging-no-codigo">
  <a href="#basicconfig-iniciando-com-logging-no-codigo">
    `basicConfig`: iniciando com `logging` no c√≥digo
  </a>
</h2>

`basicConfig` √© uma fun√ß√£o do m√≥dulo `logging`, feita para configurar o `root`
logger de forma simples e r√°pida. Geralmente, ela ser√° usada em scripts menores
para facilitar a configura√ß√£o r√°pida do `logging`.

Dependendo de quais argumentos forem usados, ela pode configurar handlers
diferentes no `root logger`.

---

<h3 id="streamhandler-saida-para-stderr-ou-stdout">
  <a href="#streamhandler-saida-para-stderr-ou-stdout">
    `StreamHandler`: sa√≠da para `stderr` ou `stdout`
  </a>
</h3>

Se voc√™ n√£o enviar o argumento `filename` para `basicConfig`, o handler padr√£o
usado ser√° um `StreamHandler`.

O termo _stream_ se refere a objetos semelhantes a arquivos, ou seja, objetos
que possuem m√©todos como `.write()` e `.flush()`. Tanto `sys.stdout` quanto
`sys.stderr` s√£o exemplos desses objetos.

Por padr√£o, o `StreamHandler` escreve no `stderr`. J√° o `print()` padr√£o do
Python escreve no `stdout`. Ou seja: ambos "printam", mas v√£o pra fluxos
diferentes.

> **Nota:** √â poss√≠vel trocar o stream da classe `StreamHandler`, passando um
> argumento como `sys.stdout`, mas isso foge do nosso foco aqui.

---

**C√≥digo: `basicConfig` + `StreamHandler`**

Primeiro, importamos o m√≥dulo `logging` e definimos o formato de cada linha de
log:

```python
import logging

# Formato do log - veja todos os atributos dispon√≠veis em:
# https://docs.python.org/3/library/logging.html#logrecord-attributes
simple_format = "%(levelname)s|%(name)s|%(asctime)s|%(message)s|%(filename)s|%(lineno)d"

# Isso configura o root logger conforme explico a seguir.
logging.basicConfig(format=simple_format)
```

O trecho acima faz o seguinte:

- Cria um `StreamHandler` que envia os logs para o `stderr`;
- Aplica um `Formatter` com o formato definido;
- Adiciona esse handler ao _root logger_;
- Define o n√≠vel do _root logger_ como `WARNING` (padr√£o do Python, caso n√£o
  seja especificado).

Com isso, o _root logger_ j√° est√° pronto pra uso. Basta fazer:

```python
# Logando com o root (n√£o vamos usar isso, s√≥ exemplo)
logging.warning("Oi!")
```

> **Nota:** O `basicConfig` aceita v√°rios outros argumentos, como `level`,
> `filename`, `filemode`, `handlers`, `stream` e mais. Se voc√™ quiser, pode
> definir o n√≠vel diretamente, por exemplo: `level=logging.DEBUG`.

---

**`getLogger()` cria ou acessa nosso pr√≥prio logger**

Com o _root logger_ configurado, a gente pode usar a fun√ß√£o `getLogger()` para
criar (ou acessar) nossos pr√≥prios loggers. Essa fun√ß√£o tem tr√™s comportamentos
distintos, dependendo do argumento:

- `logging.getLogger()`: sem argumento, retorna o _root logger_.
- `logging.getLogger("meuapp")`: com um nome, cria um novo logger se ainda n√£o
  existir.
- `logging.getLogger("meuapp")`: nas pr√≥ximas chamadas com o mesmo nome, retorna
  o mesmo logger criado anteriormente (singleton por nome).

Depois de criado, voc√™ pode definir o **n√≠vel de severidade** que esse logger
vai aceitar:

```python
logger = logging.getLogger("meuapp")
logger.setLevel(logging.DEBUG)
```

Feito isso, j√° pode come√ßar a mandar logs e ver tudo aparecendo no terminal:

```python
# Exibe logs com StreamHandler via stderr
# debug info warning error critical
logger.debug("mensagem de log")
logger.info("mensagem de log")
logger.warning("mensagem de log")
logger.error("mensagem de log")
logger.critical("mensagem de log")

# Exception
try:
    print(1 / 0)
except ZeroDivisionError:
    logger.exception("dividiu por zero a√≠")
```

Sa√≠da esperada:

```
DEBUG|meuapp|2025-06-29 17:36:09,226|mensagem de log|main.py|24
INFO|meuapp|2025-06-29 17:36:09,226|mensagem de log|main.py|25
WARNING|meuapp|2025-06-29 17:36:09,226|mensagem de log|main.py|26
ERROR|meuapp|2025-06-29 17:36:09,226|mensagem de log|main.py|27
CRITICAL|meuapp|2025-06-29 17:36:09,226|mensagem de log|main.py|28
ERROR|meuapp|2025-06-29 17:36:09,226|dividiu por zero a√≠|main.py|34
Traceback (most recent call last):
  File "main.py", line 32, in <module>
    print(1 / 0)
          ~~^~~
ZeroDivisionError: division by zero
```

---

**C√≥digo completo para `basicConfig` e `StreamHandler`**

O c√≥digo completo ficou assim:

```python
import logging

# Formato para o Formatter
# Veja os atributos dispon√≠veis em:
# https://docs.python.org/3/library/logging.html#logrecord-attributes
simple_format = "%(levelname)s|%(name)s|%(asctime)s|%(message)s|%(filename)s|%(lineno)d"
logging.basicConfig(format=simple_format)

# cria o meu logger "meuapp"
logger = logging.getLogger("meuapp")
logger.setLevel(logging.DEBUG)

logger.debug("mensagem de log")
logger.info("mensagem de log")
logger.warning("mensagem de log")
logger.error("mensagem de log")
logger.critical("mensagem de log")

try:
    print(1 / 0)
except ZeroDivisionError:
    logger.exception("Algu√©m tentou dividir por zero a√≠.")
```

---

<h3 id="filehandler-saida-para-um-arquivo">
  <a href="#filehandler-saida-para-um-arquivo">
    `FileHandler`: sa√≠da para um arquivo
  </a>
</h3>

`basicConfig` tamb√©m √© capaz de escrever logs em arquivos mudando levemente os
argumentos. Precisamos passar o caminho do arquivo de log e o modo de abertura
desejado para esse arquivo.

> **Nota:** Se voc√™ mudar a pasta onde o arquivo dever√° ser salvo, essa pasta
> precisa existir, do contr√°rio ter√° um erro.

Peguei s√≥ o trecho que precisa de modifica√ß√£o no c√≥digo anterior:

```python
import logging

format1 = "%(levelname)s|%(name)s|%(asctime)s|%(message)s|%(filename)s|%(lineno)d"

# Migrar para arquivo: basta informar o caminho, modo de abertura e encoding.
logging.basicConfig(
    level=logging.DEBUG,
    format=format1,
    filename="log.log",
    filemode="a",
    encoding="utf-8",
)

# Meu logger -> meuapp (root -> meuapp)
logger = logging.getLogger("meuapp")

# Agora voc√™ n√£o ver√° mais sa√≠da no console
logger.debug("Isso deve aparecer no arquivo log.log")

# Arquivo log.log
# DEBUG|meuapp|2025-07-05 10:12:30,311|Isso deve aparecer no arquivo log.log|lesson01.py|20
```

Ao fazer essa configura√ß√£o, em vez de usar o `StreamHandler` que vimos
anteriormente, agora ele usa o `FileHandler`. Para esse handler, precisamos do
caminho do arquivo (`filename`), do modo de abertura (`filemode`) e do
`encoding`.

Um ponto importante aqui √© que voc√™ **n√£o ver√° mais nada no terminal**, porque o
nosso handler agora envia apenas para o arquivo, e n√£o para `stderr` ou
`stdout`. Para ver ambos, precisamos de mais de um handler.

O `filemode` pode ser qualquer um dos modos de escrita, por exemplo:

- `a` - escreve no final do arquivo (n√£o apaga logs antigos, apenas adiciona)
- `w` - escreve no come√ßo do arquivo (apaga tudo que estava l√°)

<h3 id="basicconfig-filehandler-e-streamhandler">
  <a href="#basicconfig-filehandler-e-streamhandler">
    `basicConfig`, `FileHandler` e `StreamHandler`
  </a>
</h3>

Que tal a gente combinar tudo isso e adicionar dois handlers de uma vez? Bora
ver como usar `FileHandler` e `StreamHandler` junto com a fun√ß√£o `basicConfig`.

Vou mandar o c√≥digo completo pra ficar mais f√°cil de entender.

No exemplo abaixo, a gente cria os dois handlers manualmente e adiciona eles no
logger `root` via `basicConfig`. O resto continua o padr√£o de sempre.

A propaga√ß√£o (`propagate = True`) j√° fica ativa por padr√£o. Isso quer dizer que,
quando chamamos algo no nosso logger (que n√£o tem handler nenhum), o log √©
**propagado** para o logger acima dele, no caso, o `root`.

Como o `root` agora tem dois handlers, **os dois s√£o executados** quando o n√≠vel
de severidade bate. O resultado? Log no terminal **e** no arquivo ao mesmo
tempo.

Voc√™ poderia ter quantos handlers e formatters quisesse, todos pendurados no
`root`.

```python
import logging
import sys

format1 = "%(levelname)s|%(name)s|%(asctime)s|%(message)s|%(filename)s|%(lineno)d"

# Podemos criar nossos pr√≥prios handlers usando as classes que mencionei antes
file_handler = logging.FileHandler(
    filename="log.log",
    mode="a",
    encoding="utf-8",
)
stream_handler = logging.StreamHandler(sys.stdout)

# Nossos handlers precisam de um formatter
main_formatter = logging.Formatter(fmt=format1)

# A configura√ß√£o do formatter pode ser reutilizada.
file_handler.setFormatter(main_formatter)
stream_handler.setFormatter(main_formatter)

# configura o root logger
logging.basicConfig(handlers=[file_handler, stream_handler])

# cria o meu logger
logger = logging.getLogger("meuapp")
# define o n√≠vel do meu log
logger.setLevel(logging.DEBUG)

# Sa√≠da nos dois handlers
logger.debug("mensagem de log")
logger.info("mensagem de log")
logger.warning("mensagem de log")
logger.error("mensagem de log")
logger.critical("mensagem de log")

# Exception
try:
    print(1 / 0)
except ZeroDivisionError:
    logger.exception("Algu√©m tentou dividir por zero a√≠.")
```

A sa√≠da do c√≥digo acima fica como mostro abaixo tanto no console quando no
terminal.

```text
DEBUG|meuapp|2025-07-05 10:59:37,842|mensagem de log|lesson05_01.py|41
INFO|meuapp|2025-07-05 10:59:37,842|mensagem de log|lesson05_01.py|42
WARNING|meuapp|2025-07-05 10:59:37,842|mensagem de log|lesson05_01.py|43
ERROR|meuapp|2025-07-05 10:59:37,842|mensagem de log|lesson05_01.py|44
CRITICAL|meuapp|2025-07-05 10:59:37,842|mensagem de log|lesson05_01.py|45
ERROR|meuapp|2025-07-05 10:59:37,843|Algu√©m tentou dividir por zero a√≠.|lesson05_01.py|51
Traceback (most recent call last):
  File "/Users/luizotavio/Desktop/tutoriais_e_cursos/logging_course_yt/src/logging_course/lesson05_01.py", line 49, in <module>
    print(1 / 0)
          ~~^~~
ZeroDivisionError: division by zero
```

---

<h3 id="hierarquia-de-loggers-e-handlers">
  <a href="#hierarquia-de-loggers-e-handlers">
    Hierarquia de Loggers e Handlers
  </a>
</h3>

Para unir a teoria √† pr√°tica que exploramos, e para evitar as armadilhas mais
comuns, vamos entender com precis√£o o que acontece no sistema de `logging` do
Python:

**Pontos Fundamentais para Lembrar:**

1. **`basicConfig()`**: √â a fun√ß√£o de conveni√™ncia que configura o `root` logger
   (o "pai" de todos). Por padr√£o, ele adiciona um `StreamHandler` (para o
   console), um `Formatter` b√°sico e define o `level` do `root` para `WARNING`.
   Em sistemas menores, √© tranquilo usar, mas em sistemas maiores usaremos
   `dictConfig` que falaremos adiante.

2. **`getLogger('nome')`**: Cria (ou obt√©m) um `Logger` nomeado, que √© filho do
   `root` logger (ou de outro logger se o nome tiver pontos, como `app.modulo`).

3. **`setLevel()`**: Usado para definir o n√≠vel m√≠nimo de mensagens que um
   `Logger` ou um `Handler` ir√° processar.

4. **M√©todos de Log**: `debug()`, `info()`, `warning()`, `error()` e
   `critical()` s√£o os m√©todos que voc√™ usa em um `Logger` para emitir mensagens
   com um n√≠vel de gravidade espec√≠fico.

---

**A Grande Sacada: A Propaga√ß√£o e a Filtragem**

Esta √© a parte crucial e onde a maioria dos materiais simplifica demais. Preste
muita aten√ß√£o aqui!

1. **M√∫ltiplos Handlers:** Um `Logger` pode ter um ou v√°rios `Handlers` anexados
   a ele.

2. **Handlers e Formatters:** Cada `Handler` √© respons√°vel por direcionar o log
   para um destino (console, arquivo, etc.) e sempre usar√° um √∫nico `Formatter`
   para definir como a mensagem ser√° exibida. Ele tamb√©m pode ter `Filters` (que
   veremos depois) para um controle ainda mais fino.

3. **N√≠veis Duplos:** Tanto o `Logger` (o coletor de logs) quanto o `Handler` (o
   publicador de logs) possuem seu pr√≥prio `level`. Esta √© a fonte de poss√≠veis
   problemas e pode te deixar debugando o pr√≥prio `logging` por horas.

---

**A Propaga√ß√£o: O Caminho Real do Log (e o Papel dos Handlers)**

Quando um log √© emitido por um `Logger` nomeado, ele percorre uma jornada pela
hierarquia. Esse "caminho" pode ser confuso, porque n√£o √© apenas o `Logger` que
est√° filtrando, os `Handlers` tamb√©m entram no jogo.

Imagine a hierarquia de loggers assim:

```text
root           [root_handler_1, root_handler_2]
‚îî‚îÄ‚îÄ A          [A_handler_1]
    ‚îî‚îÄ‚îÄ A.B    [B_handler_1, B_handler_2, B_handler_3]
```

Vamos supor que o `level` de `A.B` foi configurado como `INFO` (20) e que
emitimos:

```python
A.B.warning("Mensagem de Exemplo")
```

**No `Logger` `A.B` (o emissor do log)**

A primeira filtragem acontece aqui. O log tem `level` `WARNING` (30), e o logger
`A.B` aceita logs com `INFO` (20) ou superior. Ent√£o a verifica√ß√£o √© simples:

```text
level do log >= level do logger ‚Üí ok
```

Se passar aqui, segue adiante. Se **n√£o** passar, o log morre aqui, **n√£o chega
em nenhum handler**.

**Nos Handlers de `A.B`**

Agora o log chega nos `Handlers` do logger `A.B`, no exemplo: `B_handler_1`,
`B_handler_2` e `B_handler_3`.

Cada handler faz **sua pr√≥pria checagem de level**. Se o log for aceito, √©
publicado por aquele handler. Se n√£o, √© ignorado por ele (mas ainda pode ser
aceito pelos outros handlers ou loggers superiores).

**No Logger `A` (pai de `A.B`)**

Se a propriedade `propagate` estiver `True` (valor padr√£o), o log **sobe na
hierarquia** e chega ao logger `A`.

Mas aqui vem a **pegadinha**: o `level` do logger `A` **n√£o importa mais**. Ele
**n√£o √© checado**. A partir daqui, s√≥ os `handlers` dos loggers pais √© que
decidem o que fazer.

**Nos Handlers de `A`**

Cada handler de `A` (ex: `A_handler_1`) faz a mesma checagem de sempre:
`level do log >= level do handler`. Se passar, o log √© publicado.

**No Logger `root` (e seus handlers)**

Mais do mesmo: o log chega no logger `root`, ignora o `level` dele, e √©
analisado apenas pelos handlers `root_handler_1` e `root_handler_2`.

---

Essa explica√ß√£o √© importante porque muita gente pensa que os loggers pais t√™m o
poder de **interromper** ou **descartar** um log que subiu pela propaga√ß√£o. Mas
n√£o t√™m. O √∫nico logger com poder de barrar a mensagem √© **o que emitiu o log**.

Se fosse pra resumir num post-it:

> O log √© verificado **no logger que o emitiu**. Se passar, √© entregue aos seus
> `handlers` e, com `propagate = True`, sobe para os loggers pais. Mas a partir
> da√≠, **apenas os `handlers` desses loggers superiores** fazem checagem. Os
> loggers pais **n√£o barram** mais nada.
>
> Se o logger emissor n√£o aceitar o log, **acabou o jogo ali**. Nada √©
> publicado.

---

<h2 id="loggers-de-terceiros-podem-entrar-no-seu-log">
  <a href="#loggers-de-terceiros-podem-entrar-no-seu-log">
    Loggers de terceiros podem entrar no seu log
  </a>
</h2>

Se voc√™ usar o `logging` de forma incorreta: tipo deixando o `level` do `root`
em `DEBUG` ou usando o `root` como logger principal por algum motivo. Uma coisa
muito comum que costuma ocorrer √© voc√™ come√ßar a ver logs de `DEBUG` de
aplica√ß√µes de terceiros no seu log.

Geralmente queremos logs de libs de terceiros no nosso log, mas n√£o um milh√£o de
`DEBUGs`. Talvez apenas de `WARNING` para cima, ou at√© de `ERROR` para cima.

Vamos simular e corrigir isso a seguir.

---

<h3 id="rich-logs-mais-bonitos-no-console">
  <a href="#rich-logs-mais-bonitos-no-console">
    `rich`: cobaia e nossos logs mais bonitos no console
  </a>
</h3>

Vamos usar a biblioteca `rich` pra deixar os logs do console mais agrad√°veis de
ler, com cor, syntax highlight e outros agrados visuais. S√≥ que vamos usar essa
lib bem mais adiante no texto.

Mesmo assim, instale-a com o gerenciador que preferir e vamos usar ela mesmo
como exemplo de log de terceiros:

```bash
# Usando uv
uv add rich

# Ou com pip
pip install rich
```

---

<h3 id="exemplo-pratico-logs-de-terceiros-poluindo-sua-saida">
  <a href="#exemplo-pratico-logs-de-terceiros-poluindo-sua-saida">
    Exemplo pr√°tico: logs de terceiros no seu log com rich
  </a>
</h3>

Vamos configurar o `logging` novamente, do zero, s√≥ que com `root` configurado
em `level` `DEBUG` (N√£o recomendado):

```python
import logging

simple_format = "%(levelname)s|%(name)s|%(asctime)s|%(message)s|%(filename)s|%(lineno)d"

# Configura o root logger com:
# - StreamHandler (stderr)
# - Formatter customizado
# - Level DEBUG
logging.basicConfig(format=simple_format, level=logging.DEBUG)

# Cria o nosso logger, mas sem handlers pr√≥prios
logger = logging.getLogger("meuapp")
logger.setLevel(logging.DEBUG)

# Apenas um teste
logger.warning("Isso √© um teste")

# Sa√≠da esperada:
# WARNING|meuapp|2025-07-01 19:44:54,566|Isso √© um teste|main.py|14
```

Agora, vamos simular o uso do `rich`, que √© uma lib que **tamb√©m usa o m√≥dulo
`logging` internamente**. Suponha que voc√™ queira imprimir um markdown no
terminal:

```python
from rich import print as rprint
from rich.markdown import Markdown

md = Markdown("# Nos Handlers de `A`")
rprint(md)
```

Se algum c√≥digo interno do `rich` emitir logs, mesmo que voc√™ n√£o pe√ßa, esses
logs v√£o aparecer, porque o `root` logger est√° **aberto no n√≠vel `DEBUG`** e
**todos os handlers est√£o l√°**.

Esse √© o tipo de polui√ß√£o que voc√™ pode querer evitar.

Isso era s√≥ pra ser um c√≥digo normal, simulando algo dentro da minha aplica√ß√£o.
Mas olha s√≥ o que apareceu no log:

> **Nota:** eu cortei bastante texto do log abaixo, mas dependendo do que voc√™
> estiver fazendo, pode ficar **absurdamente longo**. Em alguns casos, aparecem
> **tantos logs** que sua aplica√ß√£o (ou at√© seu computador) pode travar.

```text
WARNING|meuapp|2025-07-01 20:02:21,221|Isso √© um teste|main.py|14
DEBUG|markdown_it.rules_block.code|2025-07-01 20:02:21,271...
DEBUG|markdown_it.rules_block.fence|2025-07-01 20:02:21,271...
DEBUG|markdown_it.rules_block.blockquote|2025-07-01 20:02:21,271...
DEBUG|markdown_it.rules_block.hr|2025-07-01 20:02:21,271...
DEBUG|markdown_it.rules_block.list|2025-07-01 20:02:21,271...
DEBUG|markdown_it.rules_block.reference|2025-07-01 20:02:21,271...
DEBUG|markdown_it.rules_block.html_block|2025-07-01 20:02:21,271...
DEBUG|markdown_it.rules_block.heading|2025-07-01 20:02:21,271...
```

Qual o problema aqui? Nenhum, **se for intencional**.

S√≥ aconteceu que a sua aplica√ß√£o e o `rich` decidiram seguir a mesma estrat√©gia:
**usar o `root` logger pra tudo**.

Quando voc√™ configura o `root` com um n√≠vel permissivo (tipo `DEBUG`), qualquer
lib que use o sistema de logging do Python pode ter suas mensagens **publicadas
nos seus handlers**, inclusive aquelas que voc√™ nunca pediu pra logar.

Como mencionei antes, √© normal querermos logs de libs de terceiros no nosso log.
Elas fazem parte da nossa aplica√ß√£o, por√©m, em um n√≠vel interessante, como
`WARNING` ou `ERROR`, e acima.

---

<h3 id="solucoes-possiveis-para-log-de-libs-de-terceiros">
  <a href="#solucoes-possiveis-para-log-de-libs-de-terceiros">
    Solu√ß√µes poss√≠veis para log de libs de terceiros
  </a>
</h3>

Tem v√°rias coisas que a gente pode fazer:

- Subir o `level` do logger que est√° causando problema
- Configurar o `root` adequadamente (de `WARNING` para cima)
- Nunca usar o `root` logger diretamente como logger da sua aplica√ß√£o
- Isolar o seu logger do `root` (n√£o recomendado, mas pode ser √∫til se est√°
  criando uma lib para outras pessoas)

---

**Como subir o `level` de logs de terceiros com `getLogger`?**

No pr√≥prio log que poluiu meu console e arquivo, a **segunda coluna** mostra o
nome do logger: `markdown_it`!

Muita gente configura seus loggers como mostro a seguir. Isso √© at√© uma
recomenda√ß√£o da documenta√ß√£o se eu n√£o estiver enganado:

```python
logger = logging.getLogger(__name__)
```

Isso cria (ou acessa) um logger com o nome do m√≥dulo onde est√° sendo executado.
Exemplo: se voc√™ est√° em um pacote chamado `learn_logging`, e o m√≥dulo se chama
`config_logger.py`, o nome do logger ser√°:

- `__main__` se executar direto
- `learn_logging.config_logger` se importar de outro lugar

Mas voltando ao problema: se o log vem de `markdown_it`, basta fazer:

```python
logging.getLogger("markdown_it").setLevel(logging.INFO)
```

Geralmente isso silencia o `logger` que est√° jogando um monte de mensagens no
seu logger. Mas e se forem muitos? E se forem todas as 10 libs externas que voc√™
est√° usando num c√≥digo s√≥? E se as 10 libs que voc√™ instalou tamb√©m usam outras
100 libs? Fica impratic√°vel.

---

<h4 id="meus-handlers-nos-meus-loggers">
  <a href="#meus-handlers-nos-meus-loggers">
    Meus handlers nos meus loggers
  </a>
</h4>

Voc√™ pode configurar os **handlers no seu pr√≥prio logger**. Como estamos usando
`basicConfig`, os handlers estavam indo pro `root`. Agora vamos fazer de outro
modo. S√≥ um exemplo:

```python
import logging

# Cria um handler s√≥ nosso
stream_handler = logging.StreamHandler()
stream_handler.setLevel(logging.DEBUG)

# Cria um formatter
simple_format = "%(levelname)s|%(name)s|%(asctime)s|%(message)s|%(filename)s|%(lineno)d"
main_formatter = logging.Formatter(fmt=simple_format)
stream_handler.setFormatter(main_formatter)

# CAD√ä O ROOT??? sumiu üòé

logger = logging.getLogger("meuapp")
logger.setLevel(logging.DEBUG)
logger.addHandler(stream_handler)

logger.info("mensagem de log")
```

Pronto. Agora voc√™ n√£o ver√° mais logs do `rich` ou de qualquer lib de terceiro.
**N√£o porque bloqueamos eles**, mas porque **n√£o estamos mais ouvindo o
`root`**. E como essas libs usam o `root`, seus logs v√£o pra lugar nenhum.

> **Nota:** isso pode ser um problema, visto que libs de terceiros fazem parte
> da nossa aplica√ß√£o. \
> \
> Omitir logs de libs de terceiros √© como omitir logs de uma parte do c√≥digo que
> realmente vai para produ√ß√£o. \
> \
> O que eu faria nesse caso, seria manter um handler menos importante no meu
> pr√≥prio logger com level `DEBUG` (vejo tudo no meu handler), mas colocaria os
> handlers importantes, com n√≠veis de `WARNING` para cima, no `root` para
> continuar tendo acesso aos logs de libs de terceiros. \
> \
> Cada caso √© um caso a ser estudado.

---









    </script>
    <!-- prettier-ignore -->

    <!-- Markdown parser -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"
    ></script>
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"
    ></script>
    <script defer src="../../js/scripts.js"></script>
  </body>
</html>
