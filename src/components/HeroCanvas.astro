---
/**
 * ARQUIVO: HeroCanvas.astro
 *
 * O QUE FAZ:
 *   Canvas HTML5 que renderiza uma animacao de particulas interativas como
 *   fundo do hero. As particulas flutuam com movimento orbital ("drift
 *   planetario") e reagem ao mouse com fisica de mola (spring + force + drag).
 *   Tudo e desenhado via Canvas 2D API com requestAnimationFrame.
 *
 * USADO EM:
 *   - Hero.astro (unico local de uso — fundo da secao hero)
 *
 * CONCEITO ASTRO:
 *   - <script> no Astro: diferente do frontmatter (que roda no build/servidor),
 *     o bloco <script> roda NO NAVEGADOR do usuario. O Astro processa esse
 *     script via Vite: faz bundle, minifica e adiciona ao HTML final.
 *   - Script sem framework: este componente usa Canvas 2D puro, sem React,
 *     Vue ou qualquer framework. O Astro permite isso naturalmente — voce
 *     escreve JS/TS vanilla e ele e enviado ao client como modulo ES.
 *   - TypeScript no <script>: o Astro suporta TS direto no bloco <script>.
 *     Aqui, o type "Configs" e a classe "Particle" sao tipados com TS e
 *     compilados para JS no build.
 *   - aria-hidden="true": o canvas e puramente decorativo, entao e oculto
 *     de leitores de tela para acessibilidade.
 */
---

<canvas id='canvas-hero-dark' class='canvas-bg' aria-hidden='true'></canvas>

<script>
  type Configs = {
    spring: number;
    force: number;
    drag: number;
    particle_min_size: number;
    particle_max_size: number;
    particle_count: number;
    color: string;
    radius: number;
  };

  function canvasBg() {
    const makeCanvasBg = (canv: HTMLCanvasElement, configs: Configs) => {
      if (!canv) return;

      let w: number, h: number;

      const ctx = canv.getContext('2d');

      function resize() {
        w = canv.width = canv.clientWidth;
        h = canv.height = canv.clientHeight;
      }

      const mouse = {
        x: -9999,
        y: -9999,
        radius: configs.radius,
      };

      window.addEventListener('mousemove', e => {
        const bounds = canv.parentElement.getBoundingClientRect();
        const x = e.clientX - bounds.left;
        const y = e.clientY - bounds.top;

        mouse.x = x;
        mouse.y = y;
      });

      const radiusSq = () => mouse.radius * mouse.radius;

      class Particle {
        baseX: number;
        baseY: number;
        x: number;
        y: number;
        vx: number;
        vy: number;
        driftPhase: number;
        driftRadius: number;
        size: number;

        constructor() {
          this.baseX = Math.random() * w;
          this.baseY = Math.random() * h;

          this.x = this.baseX;
          this.y = this.baseY;

          this.vx = 0;
          this.vy = 0;

          // drift planetário
          this.driftPhase = Math.random() * Math.PI * 2;
          this.driftRadius = 10 + Math.random() * 20;

          this.size =
            Math.random() *
              (configs.particle_max_size - configs.particle_min_size) +
            configs.particle_min_size;
        }

        update() {
          this.driftPhase += 0.01;

          const targetX =
            this.baseX + Math.cos(this.driftPhase) * this.driftRadius;

          const targetY =
            this.baseY + Math.sin(this.driftPhase) * this.driftRadius;

          this.vx += (targetX - this.x) * configs.spring;
          this.vy += (targetY - this.y) * configs.spring;

          const dx = this.x - mouse.x;
          const dy = this.y - mouse.y;
          const distSq = dx * dx + dy * dy;

          if (distSq < radiusSq()) {
            const dist = Math.sqrt(distSq);
            const nx = dx / dist;
            const ny = dy / dist;

            const force = Math.pow(1 - dist / mouse.radius, 2);

            this.vx += nx * force * configs.force;
            this.vy += ny * force * configs.force;
          }

          this.vx -= this.vx * configs.drag;
          this.vy -= this.vy * configs.drag;

          this.x += this.vx;
          this.y += this.vy;
        }

        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = configs.color;
          ctx.fill();
        }
      }

      let particles = [];

      function rebuildParticles() {
        particles = Array.from(
          { length: configs.particle_count },
          () => new Particle(),
        );
      }

      function loop() {
        ctx.clearRect(0, 0, w, h);

        for (const p of particles) {
          p.update();
          p.draw();
        }

        requestAnimationFrame(loop);
      }

      let resizeTimeout: NodeJS.Timeout;

      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);

        resizeTimeout = setTimeout(() => {
          resize();
          rebuildParticles();
        }, 150);
      });

      resize();
      rebuildParticles();
      loop();
    };

    const canvas = document.getElementById(
      'canvas-hero-dark',
    ) as HTMLCanvasElement;

    makeCanvasBg(canvas, {
      spring: 0.01,
      force: 25,
      drag: 0.4,
      particle_min_size: 0.1,
      particle_max_size: 2,
      particle_count: 200,
      color: 'rgba(255, 255, 255, 0.8)',
      radius: 200,
    });
  }

  canvasBg();
</script>
