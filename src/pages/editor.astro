---
import BlankLayout from '../layouts/BlankLayout.astro';

const editorSchema = {
  '@context': 'https://schema.org',
  '@type': 'SoftwareApplication',
  name: 'Markdown Editor',
  applicationCategory: 'DeveloperApplication',
  operatingSystem: 'Any',
  isAccessibleForFree: true,
  description:
    'Editor Markdown com Monaco, Vim mode e preview em tempo real no navegador.',
  url: 'https://www.otaviomiranda.com.br/editor/',
  author: {
    '@type': 'Person',
    name: 'Otávio Miranda',
  },
};
---

<BlankLayout
  title='Markdown Editor com Vim e Preview ao Vivo | Otávio Miranda'
  description='Editor Markdown gratuito com Monaco Editor, Vim motions, busca com regex e preview ao vivo. Abra, edite e salve arquivos .md direto no navegador.'
>
  <script
    is:inline
    type='application/ld+json'
    set:html={JSON.stringify(editorSchema)}
  />

  <div class='editor-shell'>
    <header class='editor-toolbar'>
      <h1 class='editor-title'>Markdown Editor</h1>
      <span id='editor-file' class='editor-file'>untitled.md</span>
      <span id='editor-vim-status' class='editor-vim-status'
        >Vim: carregando...</span
      >
      <div class='editor-actions'>
        <button id='editor-new' type='button'>Novo</button>
        <button id='editor-open' type='button'>Abrir</button>
        <button id='editor-frontmatter' type='button'>Frontmatter</button>
        <button id='editor-vim-toggle' type='button' data-active='false'>
          Vim OFF
        </button>
        <button id='editor-save' type='button'>Salvar</button>
        <button id='editor-save-as' type='button'>Salvar Como</button>
      </div>
    </header>

    <div class='editor-panes'>
      <section class='editor-pane editor-pane--code'>
        <div id='editor-monaco' class='editor-monaco'></div>
      </section>

      <section class='editor-pane editor-pane--preview'>
        <article id='editor-preview' class='editor-preview'></article>
      </section>
    </div>
  </div>

  <input
    id='editor-open-input'
    type='file'
    hidden
    accept='.md,.markdown,text/markdown,text/plain'
  />

  <script is:inline src='https://cdn.jsdelivr.net/npm/marked/marked.min.js'
  ></script>
  <script
    is:inline
    src='https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js'
  ></script>
  <script is:inline>
    (() => {
      const fileLabel = document.getElementById('editor-file');
      const previewEl = document.getElementById('editor-preview');
      const openInput = document.getElementById('editor-open-input');

      const newButton = document.getElementById('editor-new');
      const openButton = document.getElementById('editor-open');
      const frontmatterButton = document.getElementById('editor-frontmatter');
      const vimToggleButton = document.getElementById('editor-vim-toggle');
      const vimStatus = document.getElementById('editor-vim-status');
      const saveButton = document.getElementById('editor-save');
      const saveAsButton = document.getElementById('editor-save-as');

      const supportsFSApi =
        'showOpenFilePicker' in window && 'showSaveFilePicker' in window;
      const AUTO_SAVE_INTERVAL_MS = 60_000;

      const nowDate = () => new Date().toLocaleDateString('sv-SE');
      const frontmatterTemplate = () =>
        `---\ntitle: ''\ndescription: ''\ndate: ${nowDate()}\nauthor: 'Otávio Miranda'\n---\n\n`;

      let editor;
      let fileHandle = null;
      let currentFileName = 'untitled.md';
      let renderTimer = null;
      let vimMode = null;
      let monacoVimModule = null;
      let vimKeymapsConfigured = false;
      let vimCommandsConfigured = false;
      let autoSaveTimerId = null;
      let lastSavedContent = '';
      let isSaving = false;

      const setCurrentFileName = fileName => {
        currentFileName = fileName;
        fileLabel.textContent = fileName;
      };

      const stripFrontmatterForPreview = markdown => {
        const withoutBom = markdown.replace(/^\uFEFF/, '');
        if (
          !withoutBom.startsWith('---\n') &&
          !withoutBom.startsWith('---\r\n')
        ) {
          return markdown;
        }

        return withoutBom.replace(/^---\r?\n[\s\S]*?\r?\n---\r?\n?/, '');
      };

      const renderPreview = () => {
        if (!editor || !window.marked) return;
        const markdown = stripFrontmatterForPreview(editor.getValue());
        previewEl.innerHTML = window.marked.parse(markdown);
      };

      const schedulePreviewRender = () => {
        if (renderTimer) {
          clearTimeout(renderTimer);
        }
        renderTimer = setTimeout(renderPreview, 90);
      };

      const suggestMarkdownName = name => {
        if (!name || typeof name !== 'string') return 'untitled.md';
        return name.endsWith('.md') ? name : `${name}.md`;
      };

      const downloadFallback = () => {
        const blob = new Blob([editor.getValue()], {
          type: 'text/markdown;charset=utf-8',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = suggestMarkdownName(currentFileName);
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };

      const writeHandle = async handle => {
        const writable = await handle.createWritable();
        await writable.write(editor.getValue());
        await writable.close();
      };

      const markCurrentContentAsSaved = () => {
        if (!editor) return;
        lastSavedContent = editor.getValue();
      };

      const hasUnsavedChanges = () => {
        if (!editor) return false;
        return editor.getValue() !== lastSavedContent;
      };

      const canAutoSaveToFile = () => {
        return Boolean(supportsFSApi && fileHandle && editor);
      };

      const autoSaveIfNeeded = async () => {
        if (!canAutoSaveToFile() || !hasUnsavedChanges() || isSaving) return;
        isSaving = true;
        try {
          await writeHandle(fileHandle);
          markCurrentContentAsSaved();
        } catch (_) {
          // Keep silent; manual save flow remains available.
        } finally {
          isSaving = false;
        }
      };

      const startAutoSaveLoop = () => {
        if (autoSaveTimerId) return;
        autoSaveTimerId = window.setInterval(() => {
          autoSaveIfNeeded().catch(() => {});
        }, AUTO_SAVE_INTERVAL_MS);
      };

      const saveAs = async () => {
        if (!supportsFSApi) {
          downloadFallback();
          markCurrentContentAsSaved();
          return;
        }

        const handle = await window.showSaveFilePicker({
          suggestedName: suggestMarkdownName(currentFileName),
          types: [
            {
              description: 'Markdown',
              accept: { 'text/markdown': ['.md', '.markdown'] },
            },
          ],
        });

        isSaving = true;
        try {
          await writeHandle(handle);
          fileHandle = handle;
          setCurrentFileName(
            handle.name || suggestMarkdownName(currentFileName),
          );
          markCurrentContentAsSaved();
        } finally {
          isSaving = false;
        }
      };

      const save = async () => {
        if (!editor) return;
        if (!supportsFSApi) {
          downloadFallback();
          markCurrentContentAsSaved();
          return;
        }

        if (!fileHandle) {
          await saveAs();
          return;
        }

        isSaving = true;
        try {
          await writeHandle(fileHandle);
          markCurrentContentAsSaved();
        } finally {
          isSaving = false;
        }
      };

      const insertFrontmatterIfMissing = () => {
        if (!editor) return;
        const value = editor.getValue().trimStart();
        if (value.startsWith('---')) return;
        editor.setValue(`${frontmatterTemplate()}${editor.getValue()}`);
      };

      const createNewDocument = () => {
        fileHandle = null;
        setCurrentFileName('untitled.md');
        editor.setValue('');
        markCurrentContentAsSaved();
      };

      const openWithFallbackInput = () => {
        openInput.value = '';
        openInput.click();
      };

      const openFromFileSystem = async () => {
        if (!supportsFSApi) {
          openWithFallbackInput();
          return;
        }

        const [handle] = await window.showOpenFilePicker({
          multiple: false,
          types: [
            {
              description: 'Markdown',
              accept: {
                'text/markdown': ['.md', '.markdown'],
                'text/plain': ['.txt'],
              },
            },
          ],
        });

        const file = await handle.getFile();
        const text = await file.text();
        fileHandle = handle;
        setCurrentFileName(file.name || 'untitled.md');
        editor.setValue(text);
        markCurrentContentAsSaved();
      };

      const setVimUiState = ({ enabled, available }) => {
        if (!vimToggleButton || !vimStatus) return;

        if (!available) {
          vimToggleButton.disabled = true;
          vimToggleButton.dataset.active = 'false';
          vimToggleButton.textContent = 'Vim indisponível';
          vimStatus.textContent = 'Vim: plugin indisponível';
          return;
        }

        vimToggleButton.disabled = false;
        vimToggleButton.dataset.active = enabled ? 'true' : 'false';
        vimToggleButton.setAttribute(
          'aria-pressed',
          enabled ? 'true' : 'false',
        );
        vimToggleButton.textContent = enabled ? 'Vim ON' : 'Vim OFF';
        vimStatus.textContent = enabled ? '-- NORMAL --' : 'Vim: desativado';
      };

      const disableVimMode = () => {
        if (!vimMode) return;
        vimMode.dispose();
        vimMode = null;
        setVimUiState({ enabled: false, available: true });
      };

      const enableVimMode = () => {
        if (!editor || !monacoVimModule?.initVimMode || vimMode) return;
        vimMode = monacoVimModule.initVimMode(editor, vimStatus);
        setVimUiState({ enabled: true, available: true });
      };

      const configureVimKeymaps = () => {
        if (vimKeymapsConfigured) return;
        const vimApi = monacoVimModule?.VimMode?.Vim;
        if (!vimApi?.map) return;

        // Faster escape from insert mode, similar to common Neovim setup.
        vimApi.map('jj', '<Esc>', 'insert');
        vimKeymapsConfigured = true;
      };

      const configureVimCommands = () => {
        if (vimCommandsConfigured) return;
        const vimApi = monacoVimModule?.VimMode?.Vim;
        if (!vimApi?.defineEx) return;

        vimApi.defineEx('write', 'w', () => {
          save().catch(() => {});
        });
        vimApi.defineEx('wq', 'wq', () => {
          save().catch(() => {});
        });

        vimCommandsConfigured = true;
      };

      const loadMonaco = () =>
        new Promise(resolve => {
          const waitForRequire = () => {
            if (!window.require) {
              setTimeout(waitForRequire, 25);
              return;
            }

            window.require.config({
              paths: {
                vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs',
                'monaco-vim':
                  'https://cdn.jsdelivr.net/npm/monaco-vim@0.4.2/dist/monaco-vim',
              },
            });

            window.require(
              ['vs/editor/editor.main', 'monaco-vim'],
              (_editorMain, monacoVim) => {
                resolve({ monaco: window.monaco, monacoVim });
              },
              () => {
                window.require(['vs/editor/editor.main'], () => {
                  resolve({ monaco: window.monaco, monacoVim: null });
                });
              },
            );
          };

          waitForRequire();
        });

      const boot = async () => {
        const { monaco, monacoVim } = await loadMonaco();
        monacoVimModule = monacoVim;

        monaco.editor.defineTheme('otavio-dark', {
          base: 'vs-dark',
          inherit: true,
          rules: [],
          colors: {
            'editor.background': '#0b1020',
            'editorLineNumber.foreground': '#7680a4',
            'editorLineNumber.activeForeground': '#dbe2ff',
          },
        });

        editor = monaco.editor.create(
          document.getElementById('editor-monaco'),
          {
            value: '',
            language: 'markdown',
            theme: 'otavio-dark',
            fontSize: 16,
            minimap: { enabled: false },
            automaticLayout: true,
            wordWrap: 'on',
            lineNumbersMinChars: 3,
            scrollBeyondLastLine: false,
          },
        );

        editor.onDidChangeModelContent(schedulePreviewRender);
        renderPreview();

        if (monacoVimModule?.initVimMode) {
          configureVimKeymaps();
          configureVimCommands();
          enableVimMode();
        } else {
          setVimUiState({ enabled: false, available: false });
        }

        openInput.addEventListener('change', async event => {
          const file = event.target.files?.[0];
          if (!file) return;
          const text = await file.text();
          fileHandle = null;
          setCurrentFileName(file.name || 'untitled.md');
          editor.setValue(text);
          markCurrentContentAsSaved();
        });

        newButton.addEventListener('click', createNewDocument);
        openButton.addEventListener('click', () => {
          openFromFileSystem().catch(() => {});
        });
        frontmatterButton.addEventListener('click', insertFrontmatterIfMissing);
        vimToggleButton.addEventListener('click', () => {
          if (!monacoVimModule?.initVimMode) return;
          if (vimMode) {
            disableVimMode();
            return;
          }
          enableVimMode();
        });
        saveButton.addEventListener('click', () => {
          save().catch(() => {});
        });
        saveAsButton.addEventListener('click', () => {
          saveAs().catch(() => {});
        });

        window.addEventListener('keydown', event => {
          const key = event.key.toLowerCase();
          const ctrlOrCmd = event.metaKey || event.ctrlKey;
          if (!ctrlOrCmd) return;

          if (key === 's') {
            event.preventDefault();
            save().catch(() => {});
            return;
          }

          if (key === 'o') {
            event.preventDefault();
            openFromFileSystem().catch(() => {});
          }
        });

        window.addEventListener('beforeunload', event => {
          autoSaveIfNeeded().catch(() => {});
          if (!hasUnsavedChanges()) return;
          event.preventDefault();
        });

        window.addEventListener('pagehide', () => {
          autoSaveIfNeeded().catch(() => {});
        });

        startAutoSaveLoop();
      };

      boot();
    })();
  </script>
</BlankLayout>

<style>
  :root {
    --editor-bg: #090d1a;
    --editor-panel: #10182d;
    --editor-panel-soft: #121b35;
    --editor-border: #2f3f68;
    --editor-text: #f0f4ff;
    --editor-text-soft: #b4c2eb;
    --editor-accent: #3a86ff;
  }

  html,
  body {
    margin: 0;
    background:
      radial-gradient(1200px 600px at 10% 0%, #122450, transparent),
      radial-gradient(1000px 500px at 90% 0%, #1a2a4d, transparent),
      var(--editor-bg);
    color: var(--editor-text);
    font-family:
      ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono',
      'Courier New', monospace;
  }

  .editor-shell {
    height: 100vh;
    display: grid;
    grid-template-rows: auto 1fr;
    overflow: hidden;
  }

  .editor-toolbar {
    display: flex;
    align-items: center;
    gap: 1.2rem;
    padding: 1.2rem 1.6rem;
    border-bottom: 1px solid var(--editor-border);
    background: color-mix(in hsl, var(--editor-panel), black 20%);
  }

  .editor-title {
    font-size: 1.6rem;
    font-weight: 800;
    color: var(--editor-text);
    letter-spacing: 0.03em;
    margin-right: 0.8rem;
    margin-block: 0;
  }

  .editor-file {
    font-size: 1.3rem;
    color: var(--editor-text-soft);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 34ch;
    margin-right: auto;
  }

  .editor-actions {
    display: flex;
    gap: 0.8rem;
    flex-wrap: wrap;
  }

  .editor-actions button {
    border: 1px solid var(--editor-border);
    background: color-mix(in hsl, var(--editor-panel-soft), black 18%);
    color: var(--editor-text);
    font: inherit;
    font-size: 1.2rem;
    font-weight: 700;
    padding: 0.6rem 1rem;
    border-radius: 999px;
    cursor: pointer;
  }

  .editor-actions button:hover {
    border-color: var(--editor-accent);
  }

  .editor-actions button[data-active='true'] {
    border-color: #00d084;
    background: color-mix(in hsl, #00d084 16%, var(--editor-panel-soft));
  }

  .editor-actions button:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }

  .editor-vim-status {
    font-size: 1.15rem;
    color: var(--editor-text-soft);
    border: 1px solid var(--editor-border);
    border-radius: 999px;
    padding: 0.4rem 0.8rem;
    white-space: nowrap;
  }

  .editor-panes {
    display: grid;
    grid-template-columns: minmax(540px, 1fr) minmax(420px, 0.9fr);
    gap: 1.2rem;
    padding: 1.2rem;
    height: 100%;
    min-height: 0;
  }

  .editor-pane {
    min-height: 0;
    border: 1px solid var(--editor-border);
    border-radius: 1.2rem;
    overflow: hidden;
    background: color-mix(in hsl, var(--editor-panel), black 14%);
  }

  .editor-monaco {
    width: 100%;
    height: 100%;
  }

  .editor-preview {
    height: 100%;
    overflow: auto;
    padding: 2.2rem;
    line-height: 1.7;
    font-size: 1.8rem;
    color: var(--editor-text);
  }

  .editor-preview h1,
  .editor-preview h2,
  .editor-preview h3 {
    line-height: 1.2;
    margin-top: 2.4rem;
    margin-bottom: 1.2rem;
  }

  .editor-preview pre {
    overflow-x: auto;
    border: 1px solid var(--editor-border);
    border-radius: 0.8rem;
    padding: 1.2rem;
    font-size: 1.4rem;
    background: #0b1020;
  }

  .editor-preview code {
    font-size: 0.92em;
  }

  .editor-preview a {
    color: #77b0ff;
  }
</style>
