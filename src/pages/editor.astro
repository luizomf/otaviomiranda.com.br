---
import BlankLayout from '../layouts/BlankLayout.astro';

const editorSchema = {
  '@context': 'https://schema.org',
  '@type': 'SoftwareApplication',
  name: 'Markdown Editor',
  applicationCategory: 'DeveloperApplication',
  operatingSystem: 'Any',
  isAccessibleForFree: true,
  description:
    'Editor Markdown com Monaco, Vim mode e preview em tempo real no navegador.',
  url: 'https://www.otaviomiranda.com.br/editor/',
  author: {
    '@type': 'Person',
    name: 'Otávio Miranda',
  },
};
---

<BlankLayout
  title='Markdown Editor com Vim e Preview ao Vivo | Otávio Miranda'
  description='Editor Markdown gratuito com Monaco Editor, Vim motions, busca com regex e preview ao vivo. Abra, edite e salve arquivos .md direto no navegador.'
>
  <script
    is:inline
    type='application/ld+json'
    set:html={JSON.stringify(editorSchema)}
  />

  <div class='editor-shell'>
    <header class='editor-toolbar'>
      <h1 class='editor-title'>Markdown Editor</h1>
      <span id='editor-file' class='editor-file'>untitled.md</span>
      <span id='editor-vim-status' class='editor-vim-status'
        >Vim: carregando...</span
      >
      <div class='editor-actions'>
        <button id='editor-new' type='button'>Novo</button>
        <button id='editor-open' type='button'>Abrir</button>
        <button id='editor-frontmatter' type='button'>Frontmatter</button>
        <button id='editor-vim-toggle' type='button' data-active='false'>
          Vim OFF
        </button>
        <button id='editor-preview-toggle' type='button' data-active='true'>
          Preview Seguro
        </button>
        <button
          id='editor-preview-visibility'
          type='button'
          data-active='true'
        >
          Ocultar Preview
        </button>
        <button id='editor-save' type='button'>Salvar</button>
        <button id='editor-save-as' type='button'>Salvar Como</button>
      </div>
    </header>

    <div class='editor-panes'>
      <section class='editor-pane editor-pane--code'>
        <div id='editor-monaco' class='editor-monaco'></div>
      </section>

      <section class='editor-pane editor-pane--preview'>
        <article id='editor-preview' class='editor-preview'></article>
      </section>
    </div>
  </div>

  <input
    id='editor-open-input'
    type='file'
    hidden
    accept='.md,.markdown,text/markdown,text/plain'
  />

  <script is:inline src='https://cdn.jsdelivr.net/npm/marked/marked.min.js'
  ></script>
  <script
    is:inline
    src='https://cdn.jsdelivr.net/npm/dompurify@3.2.7/dist/purify.min.js'
  ></script>
  <script
    is:inline
    src='https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js'
  ></script>
  <script is:inline>
    (() => {
      if (window.__otavioMarkdownEditorBooted) return;
      window.__otavioMarkdownEditorBooted = true;

      const fileLabel = document.getElementById('editor-file');
      const previewEl = document.getElementById('editor-preview');
      const openInput = document.getElementById('editor-open-input');

      const newButton = document.getElementById('editor-new');
      const openButton = document.getElementById('editor-open');
      const frontmatterButton = document.getElementById('editor-frontmatter');
      const vimToggleButton = document.getElementById('editor-vim-toggle');
      const previewToggleButton = document.getElementById(
        'editor-preview-toggle',
      );
      const previewVisibilityButton = document.getElementById(
        'editor-preview-visibility',
      );
      const vimStatus = document.getElementById('editor-vim-status');
      const saveButton = document.getElementById('editor-save');
      const saveAsButton = document.getElementById('editor-save-as');
      const shellEl = document.querySelector('.editor-shell');
      const panesEl = document.querySelector('.editor-panes');
      const codePaneEl = document.querySelector('.editor-pane--code');
      const previewPaneEl = document.querySelector('.editor-pane--preview');

      const supportsFSApi =
        'showOpenFilePicker' in window && 'showSaveFilePicker' in window;
      const AUTO_SAVE_INTERVAL_MS = 60_000;
      const SHIKI_THEME = 'github-dark-high-contrast';
      const SHIKI_IMPORT_URL = 'https://esm.sh/shiki@3.14.0?bundle';
      const SHIKI_LANGS = [
        'plaintext',
        'text',
        'bash',
        'shell',
        'sh',
        'javascript',
        'typescript',
        'jsx',
        'tsx',
        'json',
        'python',
        'html',
        'css',
        'yaml',
        'yml',
        'markdown',
        'sql',
        'nginx',
        'xml',
        'apache',
        'ssh-config',
      ];

      const nowDate = () => new Date().toLocaleDateString('sv-SE');
      const frontmatterTemplate = () =>
        `---\ntitle: ''\ndescription: ''\ndate: ${nowDate()}\nauthor: 'Otávio Miranda'\n---\n\n`;

      let editor;
      let fileHandle = null;
      let currentFileName = 'untitled.md';
      let renderTimer = null;
      let vimMode = null;
      let monacoVimModule = null;
      let vimKeymapsConfigured = false;
      let vimCommandsConfigured = false;
      let autoSaveTimerId = null;
      let lastSavedContent = '';
      let isSaving = false;
      let safePreviewEnabled = true;
      let previewVisible = true;
      let previewRenderNonce = 0;
      let shikiModulePromise = null;
      let shikiHighlighterPromise = null;
      let syncingFromEditor = false;
      let syncingFromPreview = false;

      const setPreviewModeUiState = () => {
        if (!previewToggleButton) return;
        previewToggleButton.dataset.active = safePreviewEnabled
          ? 'true'
          : 'false';
        previewToggleButton.setAttribute(
          'aria-pressed',
          safePreviewEnabled ? 'true' : 'false',
        );
        previewToggleButton.textContent = safePreviewEnabled
          ? 'Preview Seguro'
          : 'Preview Raw';
      };

      const setPreviewVisibilityUiState = () => {
        if (
          !previewVisibilityButton ||
          !shellEl ||
          !panesEl ||
          !codePaneEl ||
          !previewPaneEl
        ) {
          return;
        }

        previewVisibilityButton.dataset.active = previewVisible
          ? 'true'
          : 'false';
        previewVisibilityButton.setAttribute(
          'aria-pressed',
          previewVisible ? 'true' : 'false',
        );
        previewVisibilityButton.textContent = previewVisible
          ? 'Ocultar Preview'
          : 'Mostrar Preview';

        shellEl.classList.toggle('editor-shell--code-only', !previewVisible);
        panesEl.classList.toggle('editor-panes--code-only', !previewVisible);
        codePaneEl.classList.toggle('editor-pane--full', !previewVisible);
        previewPaneEl.hidden = !previewVisible;

        if (previewToggleButton) {
          previewToggleButton.disabled = !previewVisible;
        }
      };

      const setCurrentFileName = fileName => {
        currentFileName = fileName;
        fileLabel.textContent = fileName;
      };

      const stripFrontmatterForPreview = markdown => {
        const withoutBom = markdown.replace(/^\uFEFF/, '');
        if (
          !withoutBom.startsWith('---\n') &&
          !withoutBom.startsWith('---\r\n')
        ) {
          return markdown;
        }

        return withoutBom.replace(/^---\r?\n[\s\S]*?\r?\n---\r?\n?/, '');
      };

      const getScrollProgress = (scrollTop, scrollHeight, viewportHeight) => {
        const maxScrollTop = Math.max(0, scrollHeight - viewportHeight);
        if (!maxScrollTop) return 0;
        return Math.min(1, Math.max(0, scrollTop / maxScrollTop));
      };

      const syncPreviewScrollToEditor = () => {
        if (!editor || !previewVisible) return;

        const editorViewportHeight = editor.getLayoutInfo().height;
        const progress = getScrollProgress(
          editor.getScrollTop(),
          editor.getScrollHeight(),
          editorViewportHeight,
        );

        const previewMaxScrollTop = Math.max(
          0,
          previewEl.scrollHeight - previewEl.clientHeight,
        );
        syncingFromEditor = true;
        previewEl.scrollTop = progress * previewMaxScrollTop;
        syncingFromEditor = false;
      };

      const syncEditorScrollToPreview = () => {
        if (!editor || !previewVisible) return;

        const progress = getScrollProgress(
          previewEl.scrollTop,
          previewEl.scrollHeight,
          previewEl.clientHeight,
        );
        const editorViewportHeight = editor.getLayoutInfo().height;
        const editorMaxScrollTop = Math.max(
          0,
          editor.getScrollHeight() - editorViewportHeight,
        );

        syncingFromPreview = true;
        editor.setScrollTop(progress * editorMaxScrollTop);
        syncingFromPreview = false;
      };

      const getShikiModule = async () => {
        if (shikiModulePromise) return shikiModulePromise;
        shikiModulePromise = import(SHIKI_IMPORT_URL).catch(() => null);
        return shikiModulePromise;
      };

      const getShikiHighlighter = async () => {
        if (shikiHighlighterPromise) return shikiHighlighterPromise;

        shikiHighlighterPromise = (async () => {
          const shiki = await getShikiModule();
          if (!shiki?.createHighlighter) return null;

          try {
            return await shiki.createHighlighter({
              themes: [SHIKI_THEME],
              langs: SHIKI_LANGS,
            });
          } catch (_) {
            return null;
          }
        })();

        return shikiHighlighterPromise;
      };

      const inferCodeLanguage = codeEl => {
        const className = codeEl.className || '';
        const languageClass = className
          .split(/\s+/)
          .find(token => token.startsWith('language-'));

        if (!languageClass) return 'plaintext';

        const language = languageClass.replace('language-', '').trim();
        if (!language) return 'plaintext';
        return language;
      };

      const applyShikiToPreview = async renderNonce => {
        const highlighter = await getShikiHighlighter();
        if (!highlighter || renderNonce !== previewRenderNonce) return;

        const blocks = Array.from(previewEl.querySelectorAll('pre > code'));
        for (const codeEl of blocks) {
          if (renderNonce !== previewRenderNonce) return;

          const preEl = codeEl.parentElement;
          if (!preEl) continue;

          const source = codeEl.textContent || '';
          const language = inferCodeLanguage(codeEl);

          let shikiHtml = '';
          try {
            shikiHtml = highlighter.codeToHtml(source, {
              lang: language,
              theme: SHIKI_THEME,
            });
          } catch (_) {
            shikiHtml = highlighter.codeToHtml(source, {
              lang: 'plaintext',
              theme: SHIKI_THEME,
            });
          }

          const template = document.createElement('template');
          template.innerHTML = shikiHtml.trim();
          const shikiPre = template.content.firstElementChild;
          if (!shikiPre) continue;

          preEl.replaceWith(shikiPre);
        }

        syncPreviewScrollToEditor();
      };

      const renderPreview = () => {
        if (!editor || !window.marked) return;
        if (!previewVisible) return;
        const markdown = stripFrontmatterForPreview(editor.getValue());
        const renderedHtml = window.marked.parse(markdown);
        const currentRenderNonce = ++previewRenderNonce;

        if (!safePreviewEnabled) {
          previewEl.innerHTML = renderedHtml;
          requestAnimationFrame(syncPreviewScrollToEditor);
          applyShikiToPreview(currentRenderNonce).catch(() => {});
          return;
        }

        const purifier = window.DOMPurify;

        if (purifier?.sanitize) {
          previewEl.innerHTML = purifier.sanitize(renderedHtml, {
            USE_PROFILES: { html: true },
          });
          requestAnimationFrame(syncPreviewScrollToEditor);
          applyShikiToPreview(currentRenderNonce).catch(() => {});
          return;
        }

        // Fail closed: if sanitizer is unavailable, avoid injecting raw HTML.
        previewEl.textContent = markdown;
      };

      const schedulePreviewRender = () => {
        if (renderTimer) {
          clearTimeout(renderTimer);
        }
        renderTimer = setTimeout(renderPreview, 90);
      };

      const suggestMarkdownName = name => {
        if (!name || typeof name !== 'string') return 'untitled.md';
        return name.endsWith('.md') ? name : `${name}.md`;
      };

      const downloadFallback = () => {
        const blob = new Blob([editor.getValue()], {
          type: 'text/markdown;charset=utf-8',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = suggestMarkdownName(currentFileName);
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };

      const writeHandle = async handle => {
        const writable = await handle.createWritable();
        await writable.write(editor.getValue());
        await writable.close();
      };

      const markCurrentContentAsSaved = () => {
        if (!editor) return;
        lastSavedContent = editor.getValue();
      };

      const hasUnsavedChanges = () => {
        if (!editor) return false;
        return editor.getValue() !== lastSavedContent;
      };

      const canAutoSaveToFile = () => {
        return Boolean(supportsFSApi && fileHandle && editor);
      };

      const autoSaveIfNeeded = async () => {
        if (!canAutoSaveToFile() || !hasUnsavedChanges() || isSaving) return;
        isSaving = true;
        try {
          await writeHandle(fileHandle);
          markCurrentContentAsSaved();
        } catch (_) {
          // Keep silent; manual save flow remains available.
        } finally {
          isSaving = false;
        }
      };

      const startAutoSaveLoop = () => {
        if (autoSaveTimerId) return;
        autoSaveTimerId = window.setInterval(() => {
          autoSaveIfNeeded().catch(() => {});
        }, AUTO_SAVE_INTERVAL_MS);
      };

      const saveAs = async () => {
        if (!supportsFSApi) {
          downloadFallback();
          markCurrentContentAsSaved();
          return;
        }

        const handle = await window.showSaveFilePicker({
          suggestedName: suggestMarkdownName(currentFileName),
          types: [
            {
              description: 'Markdown',
              accept: { 'text/markdown': ['.md', '.markdown'] },
            },
          ],
        });

        isSaving = true;
        try {
          await writeHandle(handle);
          fileHandle = handle;
          setCurrentFileName(
            handle.name || suggestMarkdownName(currentFileName),
          );
          markCurrentContentAsSaved();
        } finally {
          isSaving = false;
        }
      };

      const save = async () => {
        if (!editor) return;
        if (!supportsFSApi) {
          downloadFallback();
          markCurrentContentAsSaved();
          return;
        }

        if (!fileHandle) {
          await saveAs();
          return;
        }

        isSaving = true;
        try {
          await writeHandle(fileHandle);
          markCurrentContentAsSaved();
        } finally {
          isSaving = false;
        }
      };

      const insertFrontmatterIfMissing = () => {
        if (!editor) return;
        const value = editor.getValue().trimStart();
        if (value.startsWith('---')) return;
        editor.setValue(`${frontmatterTemplate()}${editor.getValue()}`);
      };

      const createNewDocument = () => {
        fileHandle = null;
        setCurrentFileName('untitled.md');
        editor.setValue('');
        markCurrentContentAsSaved();
      };

      const openWithFallbackInput = () => {
        openInput.value = '';
        openInput.click();
      };

      const openFromFileSystem = async () => {
        if (!supportsFSApi) {
          openWithFallbackInput();
          return;
        }

        const [handle] = await window.showOpenFilePicker({
          multiple: false,
          types: [
            {
              description: 'Markdown',
              accept: {
                'text/markdown': ['.md', '.markdown'],
                'text/plain': ['.txt'],
              },
            },
          ],
        });

        const file = await handle.getFile();
        const text = await file.text();
        fileHandle = handle;
        setCurrentFileName(file.name || 'untitled.md');
        editor.setValue(text);
        markCurrentContentAsSaved();
      };

      const setVimUiState = ({ enabled, available }) => {
        if (!vimToggleButton || !vimStatus) return;

        if (!available) {
          vimToggleButton.disabled = true;
          vimToggleButton.dataset.active = 'false';
          vimToggleButton.textContent = 'Vim indisponível';
          vimStatus.textContent = 'Vim: plugin indisponível';
          return;
        }

        vimToggleButton.disabled = false;
        vimToggleButton.dataset.active = enabled ? 'true' : 'false';
        vimToggleButton.setAttribute(
          'aria-pressed',
          enabled ? 'true' : 'false',
        );
        vimToggleButton.textContent = enabled ? 'Vim ON' : 'Vim OFF';
        vimStatus.textContent = enabled ? '-- NORMAL --' : 'Vim: desativado';
      };

      const disableVimMode = () => {
        if (!vimMode) return;
        vimMode.dispose();
        vimMode = null;
        setVimUiState({ enabled: false, available: true });
      };

      const enableVimMode = () => {
        if (!editor || !monacoVimModule?.initVimMode || vimMode) return;
        vimMode = monacoVimModule.initVimMode(editor, vimStatus);
        setVimUiState({ enabled: true, available: true });
      };

      const configureVimKeymaps = () => {
        if (vimKeymapsConfigured) return;
        const vimApi = monacoVimModule?.VimMode?.Vim;
        if (!vimApi?.map) return;

        // Faster escape from insert mode, similar to common Neovim setup.
        vimApi.map('jj', '<Esc>', 'insert');
        vimKeymapsConfigured = true;
      };

      const configureVimCommands = () => {
        if (vimCommandsConfigured) return;
        const vimApi = monacoVimModule?.VimMode?.Vim;
        if (!vimApi?.defineEx) return;

        vimApi.defineEx('write', 'w', () => {
          save().catch(() => {});
        });
        vimApi.defineEx('wq', 'wq', () => {
          save().catch(() => {});
        });

        vimCommandsConfigured = true;
      };

      const loadMonaco = () =>
        new Promise(resolve => {
          const waitForRequire = () => {
            if (!window.require) {
              setTimeout(waitForRequire, 25);
              return;
            }

            window.require.config({
              paths: {
                vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs',
                'monaco-vim':
                  'https://cdn.jsdelivr.net/npm/monaco-vim@0.4.2/dist/monaco-vim',
              },
            });

            window.require(
              ['vs/editor/editor.main'],
              () => {
                window.require(
                  ['monaco-vim'],
                  monacoVim => {
                    resolve({ monaco: window.monaco, monacoVim });
                  },
                  () => {
                    resolve({ monaco: window.monaco, monacoVim: null });
                  },
                );
              },
              () => {
                resolve({ monaco: window.monaco, monacoVim: null });
              },
            );
          };

          waitForRequire();
        });

      const boot = async () => {
        const { monaco, monacoVim } = await loadMonaco();
        monacoVimModule = monacoVim;

        monaco.editor.defineTheme('otavio-dark', {
          base: 'vs-dark',
          inherit: true,
          rules: [],
          colors: {
            // 'editor.background': '#0b1020',
            // 'editorLineNumber.foreground': '#7680a4',
            // 'editorLineNumber.activeForeground': '#dbe2ff',
          },
        });

        editor = monaco.editor.create(
          document.getElementById('editor-monaco'),
          {
            value:
              '# Olá mundo!\n\nEste é o mesmo editor que roda no seu VS Code. Use como quiser.',
            language: 'markdown',
            theme: 'otavio-dark',
            fontSize: 14,
            minimap: { enabled: false },
            automaticLayout: true,
            wordWrap: 'off',
            lineNumbersMinChars: 3,
            scrollBeyondLastLine: false,
          },
        );

        editor.onDidChangeModelContent(schedulePreviewRender);
        editor.onDidScrollChange(() => {
          if (syncingFromPreview) return;
          syncPreviewScrollToEditor();
        });
        previewEl.addEventListener('scroll', () => {
          if (syncingFromEditor) return;
          syncEditorScrollToPreview();
        });
        setPreviewModeUiState();
        setPreviewVisibilityUiState();
        renderPreview();

        if (monacoVimModule?.initVimMode) {
          configureVimKeymaps();
          configureVimCommands();
          enableVimMode();
        } else {
          setVimUiState({ enabled: false, available: false });
        }

        openInput.addEventListener('change', async event => {
          const file = event.target.files?.[0];
          if (!file) return;
          const text = await file.text();
          fileHandle = null;
          setCurrentFileName(file.name || 'untitled.md');
          editor.setValue(text);
          markCurrentContentAsSaved();
        });

        newButton.addEventListener('click', createNewDocument);
        openButton.addEventListener('click', () => {
          openFromFileSystem().catch(() => {});
        });
        frontmatterButton.addEventListener('click', insertFrontmatterIfMissing);
        vimToggleButton.addEventListener('click', () => {
          if (!monacoVimModule?.initVimMode) return;
          if (vimMode) {
            disableVimMode();
            return;
          }
          enableVimMode();
        });
        previewToggleButton.addEventListener('click', () => {
          safePreviewEnabled = !safePreviewEnabled;
          setPreviewModeUiState();
          renderPreview();
        });
        previewVisibilityButton.addEventListener('click', () => {
          previewVisible = !previewVisible;
          setPreviewVisibilityUiState();
          if (previewVisible) {
            renderPreview();
          }
        });
        saveButton.addEventListener('click', () => {
          save().catch(() => {});
        });
        saveAsButton.addEventListener('click', () => {
          saveAs().catch(() => {});
        });

        window.addEventListener('keydown', event => {
          const key = event.key.toLowerCase();
          const ctrlOrCmd = event.metaKey || event.ctrlKey;
          if (!ctrlOrCmd) return;

          if (key === 's') {
            event.preventDefault();
            save().catch(() => {});
            return;
          }

          if (key === 'o') {
            event.preventDefault();
            openFromFileSystem().catch(() => {});
          }
        });

        window.addEventListener('beforeunload', event => {
          autoSaveIfNeeded().catch(() => {});
          if (!hasUnsavedChanges()) return;
          event.preventDefault();
        });

        window.addEventListener('pagehide', () => {
          autoSaveIfNeeded().catch(() => {});
        });

        startAutoSaveLoop();
      };

      boot();
    })();
  </script>
</BlankLayout>

<style>
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  html {
    font-size: 62.5%;
  }

  html,
  body {
    margin: 0;
    background: #eee;
    font-family:
      ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono',
      'Courier New', monospace;
  }

  .editor-shell {
    height: 100vh;
    display: grid;
    grid-template-rows: auto 1fr;
    overflow: hidden;
  }

  .editor-toolbar {
    display: flex;
    align-items: center;
    gap: 1.2rem;
    padding: 1.2rem 1.6rem;
    background: #1e1e1e;
  }

  .editor-title {
    font-size: 1.6rem;
    font-weight: 800;
    color: #eee;
    letter-spacing: 0.03em;
    margin-right: 0.8rem;
    margin-block: 0;
  }

  .editor-file {
    font-size: 1.3rem;
    color: #ccc;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 34ch;
    margin-right: auto;
  }

  .editor-actions {
    display: flex;
    gap: 0.8rem;
    flex-wrap: wrap;
  }

  .editor-actions button {
    border: 1px solid var(--editor-border);
    background: #aaa;
    color: #000;
    font: inherit;
    font-size: 1.2rem;
    font-weight: 700;
    padding: 0.6rem 1rem;
    border-radius: 999px;
    cursor: pointer;
  }

  .editor-actions button:hover {
    background: #ccc;
  }

  .editor-actions button[data-active='true'] {
    background: #aabbcc;
  }

  .editor-actions button:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }

  .editor-vim-status {
    font-size: 1.15rem;
    color: #ccc;
    border-radius: 999px;
    padding: 0.4rem 0.8rem;
    white-space: nowrap;
  }

  .editor-panes {
    display: grid;
    grid-template-columns: minmax(540px, 1fr) minmax(420px, 0.9fr);
    gap: 1.2rem;
    padding: 1.2rem;
    height: 100%;
    min-height: 0;
  }

  .editor-panes.editor-panes--code-only {
    grid-template-columns: minmax(0, 1fr);
  }

  .editor-shell.editor-shell--code-only .editor-panes {
    padding: 0;
    gap: 0;
  }

  .editor-pane {
    min-height: 0;
    border-radius: 8px;
    overflow: hidden;
    background: #1e1e1e;
  }

  .editor-pane.editor-pane--full {
    border-radius: 0;
  }

  .editor-monaco {
    width: 100%;
    height: 100%;
    padding: 1rem;
  }

  .editor-shell.editor-shell--code-only .editor-monaco {
    padding: 0;
  }

  .editor-preview {
    height: 100%;
    overflow: auto;
    padding: 2.2rem;
    line-height: 1.7;
    font-size: 1.8rem;
    color: #111;
    background: #fff;
    box-shadow: 0 0 10px hsla(0 0 5% / 0.5);
  }

  .editor-preview h1,
  .editor-preview h2,
  .editor-preview h3 {
    line-height: 1.2;
    margin-top: 2.4rem;
    margin-bottom: 1.2rem;
  }

  .editor-preview pre {
    overflow-x: auto;
    border: 1px solid var(--editor-border);
    border-radius: 0.8rem;
    padding: 1.2rem;
    font-size: 1.4rem;
    background: #ccc;
  }

  .editor-preview code {
    font-size: 0.92em;
  }

  .editor-preview a {
    color: #77b0ff;
  }
</style>
